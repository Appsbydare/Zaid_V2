/**
 * COMPLETE ENHANCED Apps Script for Vercel Mode with Custom Menu
 * Includes testing features and professional menu system
 *
 * FINAL TIMESTAMP FIX: Adjusts all timestamps by +4h during data processing.
 */

const CONFIG = {
  SHEET_ID: "1sx3ik8I-2_VcD3X1q6M4kOuo3hfkGbMa1JulPSWID9Y",
  FORMATTED_SHEET: "FORMATTED_TRANSACTIONS",
  WITHDRAWALS_SHEET: "Withdrawals",
  DEPOSITS_SHEET: "Deposits",
  SETTINGS_SHEET: "SETTINGS",
  VERCEL_CRYPTO_ENDPOINT: "https://zaid-cryptowallets.vercel.app/api/crypto-to-sheets"
};

// ===========================================
// TIMESTAMP ADJUSTMENT FUNCTION
// ===========================================

/**
 * Adjusts a timestamp string or Date object by +2 hours and ensures 24h format.
 * Handles date-only strings by adding time information.
 * @param {Date|string} timestamp The original timestamp.
 * @returns {Date} The adjusted Date object with proper time format.
 */
function adjustTimestampToGST(timestamp) {
  try {
    if (!timestamp) return new Date();

    let date;
    
    // Handle different timestamp formats
    if (typeof timestamp === 'string') {
      // If it's just a date (YYYY-MM-DD or DD/MM/YYYY format)
      if (timestamp.match(/^\d{4}-\d{2}-\d{2}$/) || timestamp.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
        // Add time component (00:00:00) to make it a full datetime
        const dateOnly = timestamp.replace(/\//g, '-'); // Convert DD/MM/YYYY to YYYY-MM-DD if needed
        date = new Date(dateOnly + 'T00:00:00Z');
      } else if (!timestamp.endsWith('Z')) {
        // If it has time but no Z, add Z to treat as UTC
        date = new Date(timestamp.replace(' ', 'T') + 'Z');
      } else {
        // Already has Z, parse as is
        date = new Date(timestamp);
      }
    } else {
      // It's already a Date object
      date = new Date(timestamp);
    }
      
    // Add 2 hours
    date.setHours(date.getHours() + 2);
    
    return date;
  } catch (error) {
    console.error(`‚ùå Error adjusting timestamp "${timestamp}":`, error);
    return (timestamp instanceof Date) ? timestamp : new Date();
  }
}

// ===========================================
// MAIN EXECUTION & WORKFLOW
// ===========================================

function mainVercelMode() {
  try {
    console.log("üöÄ Starting Vercel-mode crypto data fetch...");
    const settings = getSettingsConfiguration();
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);

    // Track last rows BEFORE fetching new data
    const withdrawalsSheet = spreadsheet.getSheetByName(CONFIG.WITHDRAWALS_SHEET);
    const depositsSheet = spreadsheet.getSheetByName(CONFIG.DEPOSITS_SHEET);
    const lastWithdrawalRow = withdrawalsSheet.getLastRow();
    const lastDepositRow = depositsSheet.getLastRow();

    // Step 1: Trigger Vercel to fetch and write raw data
    console.log("üì° Triggering Vercel data fetch...");
    const vercelResult = triggerVercelDataFetch(settings);

    // Step 2: Update the API status table in Settings with adjusted timestamps
    if (vercelResult && vercelResult.apiStatus) {
      updateApiStatusTable(vercelResult.apiStatus);
    }

    // Step 3: Adjust timestamps ONLY for new rows
    adjustTimestampsForNewRows(spreadsheet, CONFIG.WITHDRAWALS_SHEET, lastWithdrawalRow);
    adjustTimestampsForNewRows(spreadsheet, CONFIG.DEPOSITS_SHEET, lastDepositRow);

    // Step 4: Consolidate data into the final formatted sheet
    console.log("üîÑ Consolidating to formatted sheet...");
    consolidateToFormatted();
    
    // Step 5: Update the 'Last Execution' timestamp in Settings
    console.log("‚è∞ Updating last execution timestamp...");
    updateLastExecutionTime();
    
    console.log("‚úÖ Vercel-mode flow completed successfully.");
    showAlert("Success", "‚úÖ Main extraction completed successfully! Only new timestamps have been adjusted.");
  } catch (error) {
    console.error("‚ùå FATAL ERROR in main workflow:", error);
    showAlert("Fatal Error", `‚ùå Main extraction failed!\n\nError: ${error.message}`);
  }
}

function adjustTimestampsForNewRows(spreadsheet, sheetName, prevLastRow) {
  const sheet = spreadsheet.getSheetByName(sheetName);
  const newLastRow = sheet.getLastRow();
  const startRow = prevLastRow + 1;
  if (newLastRow < startRow) return; // No new rows

  // Adjust timestamps and format as string
  const range = sheet.getRange(startRow, 9, newLastRow - startRow + 1, 1); // Column I
  const values = range.getValues();
  const adjusted = values.map(row => {
    const dateObj = adjustTimestampToGST(row[0]);
    // Format as "MM/dd/yyyy HH:mm:ss"
    return [Utilities.formatDate(dateObj, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "MM/dd/yyyy HH:mm:ss")];
  });
  range.setValues(adjusted);

  // Set number format for Amount column (H)
  const amountRange = sheet.getRange(startRow, 8, newLastRow - startRow + 1, 1);
  amountRange.setNumberFormat("0.00#######");

  // Set date-time format for Timestamp column (I)
  range.setNumberFormat("MM/dd/yyyy HH:mm:ss");

  console.log(`‚úÖ Adjusted timestamps and formats for new rows in "${sheetName}" (${startRow} to ${newLastRow}).`);
}

function triggerVercelDataFetch(settings) {
  try {
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      payload: JSON.stringify({
        action: "fetch_and_write",
        startDate: settings.startDate,
      }),
      muteHttpExceptions: true
    });
    
    const responseText = response.getContentText();
    const data = JSON.parse(responseText);

    if (data.debugLogs && Array.isArray(data.debugLogs)) {
      console.log("--- üì° Vercel Debug Logs Start üì° ---");
      data.debugLogs.forEach(log => console.log(log));
      console.log("--- üì° Vercel Debug Logs End üì° ---");
    }
    
    if (response.getResponseCode() !== 200) throw new Error(`Vercel API error: ${response.getResponseCode()} - ${responseText}`);
    if (!data.success) throw new Error(`Vercel process failed: ${data.error || 'Unknown error'}`);
    
    console.log(`‚úÖ Vercel processed ${data.transactions} transactions.`);
    return data;
  } catch (error) {
    console.error("‚ùå Error triggering Vercel:", error);
    throw error;
  }
}

// ===========================================
// DATA CONSOLIDATION & FORMATTING
// ===========================================

function consolidateToFormatted() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    // Read from raw sheets and get the transaction data (NO adjustment here, just read)
    const withdrawals = readRawSheet(spreadsheet, CONFIG.WITHDRAWALS_SHEET, 'withdrawal');
    const deposits = readRawSheet(spreadsheet, CONFIG.DEPOSITS_SHEET, 'deposit');

    const allTransactions = [...withdrawals, ...deposits];
    allTransactions.sort((a, b) => b.timestamp - a.timestamp);
    updateFormattedTransactionsSheet(spreadsheet, allTransactions);

    console.log(`‚úÖ Consolidated ${allTransactions.length} transactions.`);
  } catch (error) {
    console.error("‚ùå Error in consolidateToFormatted:", error);
  }
}

function getSheetData(spreadsheet, sheetName) {
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 7) return [];
    return sheet.getRange(7, 1, sheet.getLastRow() - 6, 12).getValues();
}

function updateSheetWithAdjustedTimestamps(spreadsheet, sheetName, data) {
    if (data.length === 0) return;
    const sheet = spreadsheet.getSheetByName(sheetName);
    
    const adjustedData = data.map(row => {
        const timestamp = row[8]; // Column I is timestamp
        if (timestamp) {
            const adjustedDate = adjustTimestampToGST(timestamp);
            // --- FIX: Format to string to preserve date and time ---
            row[8] = Utilities.formatDate(adjustedDate, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "MM/dd/yyyy HH:mm:ss");
        }
        return row;
    });
    
    const dataRange = sheet.getRange(7, 1, adjustedData.length, 12);
    dataRange.setValues(adjustedData);

    // --- FIX: Explicitly set number format for Amount column (H) to preserve decimals ---
    const amountColumnIndex = 8; // Column H
    const amountRange = sheet.getRange(7, amountColumnIndex, adjustedData.length, 1);
    amountRange.setNumberFormat("0.00#######"); // A flexible format for crypto amounts

    console.log(`‚úÖ Adjusted timestamps and number formatting in "${sheetName}".`);
}

function readRawSheet(spreadsheet, sheetName, transactionType) {
  const transactions = [];
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() <= 6) return transactions;
    const data = sheet.getRange(7, 1, sheet.getLastRow() - 6, 12).getValues();
    
    data.forEach(row => {
      if (row[5] && row[6]) { // Platform and Asset must exist
        transactions.push({
          timestamp: row[8], // Read timestamp AS-IS
          platform: row[5], type: transactionType, asset: row[6],
          amount: row[7] || '0', amount_aed: row[1] || '0',
          rate: row[3] || '0', client: row[0] || '',
          remarks: row[4] || '', from_address: row[9] || '',
          to_address: row[10] || '', tx_id: row[11] || '',
        });
      }
    });
  } catch (error) { console.error(`‚ùå Error reading ${sheetName}:`, error); }
  return transactions;
}

function updateFormattedTransactionsSheet(spreadsheet, transactions) {
  try {
    const sheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    if (!sheet) throw new Error("FORMATTED_TRANSACTIONS sheet not found");

    if (sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    if (transactions.length === 0) return;

    const formattedRows = transactions.map(tx => {
      const rate = parseFloat(tx.rate) || getCryptoRate(tx.asset);
      const amount = parseFloat(tx.amount) || 0;
      const aedValue = parseFloat(tx.amount_aed) || (amount * rate);
      return [
        tx.timestamp, tx.platform, tx.type.charAt(0).toUpperCase() + tx.type.slice(1),
        tx.asset, amount.toFixed(8), `AED ${aedValue.toLocaleString()}`,
        rate, tx.client, tx.remarks, tx.from_address,
        tx.to_address, tx.tx_id
      ];
    });
    
    sheet.getRange(2, 1, formattedRows.length, 12).setValues(formattedRows);
  } catch (error) {
    console.error("‚ùå Error updating FORMATTED_TRANSACTIONS:", error);
  }
}

// ===========================================
// SETTINGS SHEET MANAGEMENT
// ===========================================

function getSettingsConfiguration() {
  try {
    const settingsSheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    const startDate = new Date(settingsSheet.getRange('H13').getValue()).toISOString();
    return { startDate };
  } catch (e) {
    return { startDate: new Date('2025-01-01').toISOString() };
  }
}

function updateLastExecutionTime() {
  try {
    const settingsSheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    settingsSheet.getRange('H16').setValue(new Date()); // Remove adjustment - use actual time
  } catch (error) {
    console.error("‚ùå Error updating last execution time:", error);
  }
}

function updateApiStatusTable(apiStatus) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    if (!sheet) return;
    
    const statusRows = Object.entries(apiStatus).map(([platform, status]) => [
        platform,
        status.status,
        status.lastSync, // Remove adjustment - use actual sync time
        status.autoUpdate,
        status.notes
    ]);

    if (statusRows.length > 0) {
      sheet.getRange('A3:E20').clearContent();
      sheet.getRange(3, 1, statusRows.length, statusRows[0].length).setValues(statusRows);
      console.log(`‚úÖ Updated ${statusRows.length} API statuses in Settings.`);
    }
  } catch (error) {
    console.error("‚ùå Error updating API status:", error);
  }
}

// ===========================================
// UTILITIES 
// ===========================================

function getCryptoRate(asset) {
  const rates = {'BTC': 220200, 'ETH': 11010, 'USDT': 3.67, 'USDC': 3.67, 'SOL': 550, 'TRX': 0.37, 'BNB': 2200, 'SEI': 1.47};
  return rates[asset] || 1;
}

function showAlert(title, message) {
  try {
    const ui = SpreadsheetApp.getUi();
    ui.alert(title, message, ui.ButtonSet.OK);
  } catch (error) {
    // Fallback to console if UI not available
    console.log(`${title}: ${message}`);
  }
}

// ===========================================
// CUSTOM MENU SYSTEM
// ===========================================

/**
 * Create custom CryptoWallet menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('üöÄ Crypto Wallet')
    .addItem('üìä Main Extraction', 'mainVercelMode')
    .addSeparator()
    .addSubMenu(ui.createMenu('üß™ Test Functions')
      .addItem('üìÖ Test Last Week', 'testLastWeekExtraction')
      .addItem('üìÖ Test 30 Days', 'testSpecificDateRange')
      .addItem('üîó Test Connection', 'testVercelConnection')
      .addItem('üìä Count Transactions', 'countCurrentTransactions')
      .addItem('üìà Test Sheet Access', 'testSheetAccess')
      .addItem('üü¢ Test TRON Wallet', 'testTronWallet'))
    .addSeparator()
    .addItem('üìñ User Guide', 'showUserGuide')
    .addToUi();
    
  console.log("‚úÖ CryptoWallet menu created successfully");
}

/**
 * Shows a comprehensive user guide with instructions and data explanations
 */
function showUserGuide() {
  const guide = `
üöÄ CRYPTO WALLET - USER GUIDE

üìä MAIN EXTRACTION:
‚Ä¢ Click "üìä Main Extraction" to start the automated data fetch
‚Ä¢ The system will fetch data from multiple crypto exchange APIs and update your sheets
‚Ä¢ All transaction timestamps are automatically adjusted to your local timezone

üìã WHAT DATA IS UPDATED:

1Ô∏è‚É£ WITHDRAWALS SHEET (Column I - Timestamps):
‚Ä¢ Binance P2P sell transactions
‚Ä¢ Binance Pay withdrawal transactions
‚Ä¢ Binance Spot trading withdrawals
‚Ä¢ Binance Futures withdrawals
‚Ä¢ Bybit P2P sell transactions
‚Ä¢ Bybit Spot trading withdrawals
‚Ä¢ Bybit Futures withdrawals
‚Ä¢ Other wallet withdrawal transactions

2Ô∏è‚É£ DEPOSITS SHEET (Column I - Timestamps):
‚Ä¢ Binance P2P buy transactions  
‚Ä¢ Binance Pay deposit transactions
‚Ä¢ Binance Spot trading deposits
‚Ä¢ Binance Futures deposits
‚Ä¢ Bybit P2P buy transactions
‚Ä¢ Bybit Spot trading deposits
‚Ä¢ Bybit Futures deposits
‚Ä¢ Other wallet deposit transactions

3Ô∏è‚É£ FORMATTED_TRANSACTIONS SHEET (Column A - Timestamps):
‚Ä¢ Consolidated view of all transactions from all platforms
‚Ä¢ Sorted by timestamp (newest first)
‚Ä¢ Complete transaction history across all exchanges

4Ô∏è‚É£ SETTINGS SHEET:
‚Ä¢ API Status Table: Shows which platforms are working
‚Ä¢ Last Sync times: When each API was last checked
‚Ä¢ Last Execution: When the main extraction was last run
‚Ä¢ Start Date: Date from which to fetch transactions

üîÑ AUTOMATED PROCESS:
1. Fetches data from multiple crypto exchange APIs
2. Writes to Withdrawals/Deposits sheets
3. Adjusts all timestamps to local timezone
4. Consolidates data to FORMATTED_TRANSACTIONS
5. Updates Settings with status information

üìä DATA SOURCES & TRANSACTION TYPES:

BINANCE:
‚Ä¢ P2P (Peer-to-Peer) transactions
‚Ä¢ Pay (Direct Pay) transactions
‚Ä¢ Spot trading transactions
‚Ä¢ Futures trading transactions
‚Ä¢ Staking rewards
‚Ä¢ Mining rewards

BYBIT:
‚Ä¢ P2P (Peer-to-Peer) transactions
‚Ä¢ Spot trading transactions
‚Ä¢ Futures trading transactions
‚Ä¢ Options trading transactions
‚Ä¢ Copy trading transactions

OTHER WALLETS:
‚Ä¢ External wallet transfers
‚Ä¢ DeFi protocol transactions
‚Ä¢ NFT marketplace transactions
‚Ä¢ Staking platform transactions

üîç TRANSACTION FILTERING:
‚Ä¢ Automatic filtering of small amounts/fees
‚Ä¢ Duplicate transaction detection
‚Ä¢ Invalid transaction removal
‚Ä¢ Transaction charge separation to RecycleBin

Need help? Check the execution logs for detailed information about the process.
`;

  try {
    SpreadsheetApp.getUi().alert('üìñ User Guide', guide, SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    console.log('User Guide:\n' + guide);
  }
}

// ===========================================
// QUICK TEST FUNCTIONS
// ===========================================

/**
 * TEST: Vercel endpoint connection
 */
function testVercelConnection() {
  try {
    console.log("üß™ Testing Vercel connection...");
    
    const testPayload = {
      action: "test_connection",
      timestamp: new Date().toISOString()
    };
    
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(testPayload),
      muteHttpExceptions: true
    });
    
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (statusCode === 200) {
      console.log("‚úÖ Vercel connection successful");
      showAlert("Success", "‚úÖ Vercel connection working perfectly!\n\nResponse: " + responseText.substring(0, 200) + "...");
    } else {
      console.error(`‚ùå Vercel connection failed: ${statusCode}`);
      showAlert("Error", `‚ùå Vercel connection failed!\n\nStatus: ${statusCode}\nResponse: ${responseText.substring(0, 200)}...`);
    }
    
  } catch (error) {
    console.error("‚ùå Error testing Vercel connection:", error);
    showAlert("Error", `‚ùå Connection test failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Count transactions in current sheets
 */
function countCurrentTransactions() {
  try {
    console.log("üîç Counting current transactions...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Count withdrawals
    const withdrawalsSheet = spreadsheet.getSheetByName(CONFIG.WITHDRAWALS_SHEET);
    const withdrawalsCount = withdrawalsSheet ? Math.max(0, withdrawalsSheet.getLastRow() - 6) : 0;
    
    // Count deposits  
    const depositsSheet = spreadsheet.getSheetByName(CONFIG.DEPOSITS_SHEET);
    const depositsCount = depositsSheet ? Math.max(0, depositsSheet.getLastRow() - 6) : 0;
    
    // Count formatted transactions
    const formattedSheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    const formattedCount = formattedSheet ? Math.max(0, formattedSheet.getLastRow() - 1) : 0;
    
    const report = `üìä Transaction Count Report:

üì§ Withdrawals: ${withdrawalsCount}
üì• Deposits: ${depositsCount}
üìà Total Raw: ${withdrawalsCount + depositsCount}
üìã Formatted: ${formattedCount}

üìÖ Last Update: ${new Date().toLocaleString()}`;

    console.log(report);
    showAlert("Transaction Count", report);
    
  } catch (error) {
    console.error("‚ùå Error counting transactions:", error);
    showAlert("Error", `‚ùå Count failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Sheet access and structure
 */
function testSheetAccess() {
  try {
    console.log("üìà Testing sheet access...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheets = spreadsheet.getSheets();
    
    let report = "üìä Sheet Access Test:\n\n";
    
    // Check each required sheet
    const requiredSheets = [CONFIG.WITHDRAWALS_SHEET, CONFIG.DEPOSITS_SHEET, CONFIG.FORMATTED_SHEET, CONFIG.SETTINGS_SHEET];
    
    requiredSheets.forEach(sheetName => {
      const sheet = spreadsheet.getSheetByName(sheetName);
      if (sheet) {
        report += `‚úÖ ${sheetName}: ${sheet.getLastRow()} rows\n`;
      } else {
        report += `‚ùå ${sheetName}: Missing!\n`;
      }
    });
    
    report += `\nüìã Total Sheets: ${sheets.length}`;
    
    console.log(report);
    showAlert("Sheet Access", report);
    
  } catch (error) {
    console.error("‚ùå Error testing sheet access:", error);
    showAlert("Error", `‚ùå Sheet test failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// SYSTEM TOOLS
// ===========================================

/**
 * Delete all existing triggers
 */
function deleteAllTriggers() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    
    if (triggers.length === 0) {
      showAlert("Info", "‚ÑπÔ∏è No triggers found to delete.");
      return;
    }
    
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    console.log(`üóëÔ∏è Deleted ${triggers.length} triggers`);
    showAlert("Success", `‚úÖ Deleted ${triggers.length} triggers successfully!`);
    
  } catch (error) {
    console.error("‚ùå Error deleting triggers:", error);
    showAlert("Error", `‚ùå Failed to delete triggers!\n\nError: ${error.message}`);
  }
}

/**
 * Show comprehensive system status
 */
function showSystemStatus() {
  try {
    console.log("üìã Generating system status...");
    
    const triggers = ScriptApp.getProjectTriggers();
    const settings = getSettingsConfiguration();
    
    let status = "üîç CryptoWallet System Status:\n\n";
    
    // Triggers status
    status += "‚öôÔ∏è TRIGGERS:\n";
    if (triggers.length === 0) {
      status += "‚ùå No triggers active\n";
    } else {
      triggers.forEach(trigger => {
        status += `‚úÖ ${trigger.getHandlerFunction()}: ${trigger.getTriggerSource()}\n`;
      });
    }
    
    // Settings status
    status += "\nüìÖ SETTINGS:\n";
    status += `Start Date: ${settings.startDate}\n`;
    status += `Last Execution: ${settings.lastExecution || 'Never'}\n`;
    
    // Sheet status
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    status += "\nüìä SHEETS:\n";
    status += `Withdrawals: ${getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET)} rows\n`;
    status += `Deposits: ${getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET)} rows\n`;
    status += `Formatted: ${getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET)} rows\n`;
    
    status += `\n‚è∞ Generated: ${new Date().toLocaleString()}`;
    
    console.log(status);
    showAlert("System Status", status);
    
  } catch (error) {
    console.error("‚ùå Error generating system status:", error);
    showAlert("Error", `‚ùå Status check failed!\n\nError: ${error.message}`);
  }
}

/**
 * Export diagnostics to new sheet
 */
function exportDiagnostics() {
  try {
    console.log("üìä Exporting diagnostics...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Create or get diagnostics sheet
    let diagnosticsSheet;
    try {
      diagnosticsSheet = spreadsheet.getSheetByName("DIAGNOSTICS");
    } catch (e) {
      diagnosticsSheet = spreadsheet.insertSheet("DIAGNOSTICS");
    }
    
    // Clear existing data
    diagnosticsSheet.clear();
    
    // Create diagnostics report
    const timestamp = new Date();
    const settings = getSettingsConfiguration();
    const triggers = ScriptApp.getProjectTriggers();
    
    const diagnosticsData = [
      ["CryptoWallet System Diagnostics", "", ""],
      ["Generated At:", timestamp.toLocaleString(), ""],
      ["", "", ""],
      ["CONFIGURATION", "", ""],
      ["Sheet ID:", CONFIG.SHEET_ID, ""],
      ["Vercel Endpoint:", CONFIG.VERCEL_CRYPTO_ENDPOINT, ""],
      ["", "", ""],
      ["SETTINGS", "", ""],
      ["Start Date:", settings.startDate, ""],
      ["Last Execution:", settings.lastExecution || "Never", ""],
      ["", "", ""],
      ["TRIGGERS", "", ""],
      ["Active Triggers:", triggers.length, ""],
      ...triggers.map(t => ["Trigger:", t.getHandlerFunction(), t.getTriggerSource()]),
      ["", "", ""],
      ["SHEET STATISTICS", "", ""],
      ["Withdrawals Rows:", getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET), ""],
      ["Deposits Rows:", getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET), ""],
      ["Formatted Rows:", getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET), ""]
    ];
    
    // Write data to sheet
    diagnosticsSheet.getRange(1, 1, diagnosticsData.length, 3).setValues(diagnosticsData);
    
    // Format the sheet
    diagnosticsSheet.getRange("A1").setFontWeight("bold").setFontSize(14);
    diagnosticsSheet.getRange("A:A").setFontWeight("bold");
    diagnosticsSheet.autoResizeColumns(1, 3);
    
    console.log("‚úÖ Diagnostics exported successfully");
    showAlert("Success", "‚úÖ Diagnostics exported to DIAGNOSTICS sheet!");
    
  } catch (error) {
    console.error("‚ùå Error exporting diagnostics:", error);
    showAlert("Error", `‚ùå Export failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST FUNCTION: Check Settings date configuration
 */
function testDateSettings() {
  try {
    const settings = getSettingsConfiguration();
    
    let report = "üìÖ Date Settings Check:\n\n";
    report += `Start Date: ${settings.startDate}\n`;
    report += `Last Execution: ${settings.lastExecution || 'Never'}\n\n`;
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    report += "üìä Raw Settings Values:\n";
    report += `H13 (Start Date): ${settingsSheet.getRange('H13').getValue()}\n`;
    report += `H16 (Last Execution): ${settingsSheet.getRange('H16').getValue()}`;
    
    console.log(report);
    showAlert("Date Settings", report);
    
  } catch (error) {
    console.error("‚ùå Error testing date settings:", error);
    showAlert("Error", `‚ùå Date settings test failed!\n\nError: ${error.message}`);
  }
}

/**
 * UTILITY: Setup date controls in Settings if missing
 */
function setupDateControls() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      showAlert("Error", "‚ùå Settings sheet not found!");
      return;
    }
    
    // Add date control labels and default values
    settingsSheet.getRange('G13').setValue('Start Date:').setFontWeight('bold');
    settingsSheet.getRange('H13').setValue(new Date('2025-05-31')); // Updated default
    
    settingsSheet.getRange('G16').setValue('Last Execution:').setFontWeight('bold');
    settingsSheet.getRange('H16').setValue('Not executed yet');
    
    // Format date cells
    settingsSheet.getRange('H13').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    settingsSheet.getRange('H16').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    
    console.log("‚úÖ Date controls set up in Settings sheet");
    showAlert("Success", "‚úÖ Date controls set up successfully!\n\nüìÖ Start Date: 2025-05-31\nüìÖ Last Execution will be updated automatically");
    
  } catch (error) {
    console.error("‚ùå Error setting up date controls:", error);
    showAlert("Error", `‚ùå Date controls setup failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// TEST FUNCTIONS FOR DEBUGGING
// ===========================================

function testLastWeekExtraction() {
  try {
    console.log("üß™ Starting LAST WEEK test extraction...");
    
    // Calculate last week's date range
    const now = new Date();
    const lastWeekStart = new Date(now);
    lastWeekStart.setDate(now.getDate() - 7);
    
    const startDate = lastWeekStart.toISOString();
    const endDate = now.toISOString();
    
    console.log(`üìÖ Test period: ${startDate} to ${endDate}`);
    
    const settings = {
      startDate: startDate,
      testMode: true
    };
    
    // Trigger Vercel with last week's date
    console.log("üì° Triggering Vercel test fetch for last week...");
    const vercelResult = triggerVercelDataFetch(settings);
    
    if (vercelResult && vercelResult.debugLogs) {
      console.log("--- üß™ TEST Debug Logs Start üß™ ---");
      vercelResult.debugLogs.forEach(log => console.log(log));
      console.log("--- üß™ TEST Debug Logs End üß™ ---");
    }
    
    console.log("üß™ Test extraction completed:", vercelResult);
    showAlert("Test Complete", `üß™ Last week test extraction completed!\n\nPeriod: ${startDate} to ${endDate}\n\nCheck execution logs for details.`);
    
  } catch (error) {
    console.error("‚ùå Error in test extraction:", error);
    showAlert("Test Error", `‚ùå Test extraction failed!\n\nError: ${error.message}`);
  }
}

function testSpecificDateRange() {
  try {
    // Test with a specific date range (last 30 days)
    const now = new Date();
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(now.getDate() - 30);
    
    const startDate = thirtyDaysAgo.toISOString();
    
    console.log(`üß™ Testing 30-day range: ${startDate} to ${now.toISOString()}`);
    
    const settings = {
      startDate: startDate,
      testMode: true
    };
    
    const vercelResult = triggerVercelDataFetch(settings);
    
    if (vercelResult && vercelResult.debugLogs) {
      console.log("--- üß™ 30-DAY TEST Debug Logs Start üß™ ---");
      vercelResult.debugLogs.forEach(log => console.log(log));
      console.log("--- üß™ 30-DAY TEST Debug Logs End üß™ ---");
    }
    
    console.log("üß™ 30-day test completed:", vercelResult);
    showAlert("30-Day Test Complete", `üß™ 30-day test extraction completed!\n\nPeriod: ${startDate} to ${now.toISOString()}\n\nCheck execution logs for details.`);
    
  } catch (error) {
    console.error("‚ùå Error in 30-day test:", error);
    showAlert("Test Error", `‚ùå 30-day test failed!\n\nError: ${error.message}`);
  }
}

function testTronWallet() {
  try {
    console.log("üß™ Testing TRON wallet API...");
    
    const tronAddress = "TAUDuQAZSTUH88xno1imPoKN25eJN6aJkN";
    const endpoint = `https://api.trongrid.io/v1/accounts/${tronAddress}/transactions?limit=50&order_by=block_timestamp,desc`;
    
    console.log(`üîó Testing TRON API endpoint: ${endpoint}`);
    
    const response = UrlFetchApp.fetch(endpoint, {
      muteHttpExceptions: true
    });
    
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    console.log(`üì° TRON API Response Status: ${statusCode}`);
    console.log(`üìä TRON API Response: ${responseText.substring(0, 500)}...`);
    
    if (statusCode !== 200) {
      throw new Error(`TRON API error: ${statusCode} - ${responseText}`);
    }
    
    const data = JSON.parse(responseText);
    
    let report = `üß™ TRON Wallet Test Results:\n\n`;
    report += `Address: ${tronAddress}\n`;
    report += `Status Code: ${statusCode}\n`;
    report += `Has Data: ${!!data.data}\n`;
    
    if (data.data) {
      report += `Raw Transactions: ${data.data.length}\n\n`;
      
      // Test processing logic
      const filterDate = new Date();
      filterDate.setDate(filterDate.getDate() - 7);
      
      let validTransactions = 0;
      let transferContracts = 0;
      
      data.data.forEach((tx, index) => {
        const txDate = new Date(tx.block_timestamp);
        if (txDate >= filterDate) {
          validTransactions++;
          
          if (tx.raw_data && tx.raw_data.contract) {
            tx.raw_data.contract.forEach(contract => {
              if (contract.type === "TransferContract") {
                transferContracts++;
              }
            });
          }
        }
      });
      
      report += `Transactions in last 7 days: ${validTransactions}\n`;
      report += `Transfer contracts found: ${transferContracts}\n`;
      
      // Show first few transactions
      if (data.data.length > 0) {
        report += `\nüìã Sample Transactions:\n`;
        data.data.slice(0, 3).forEach((tx, index) => {
          const txDate = new Date(tx.block_timestamp);
          report += `${index + 1}. ${tx.txID}\n`;
          report += `   Date: ${txDate.toISOString()}\n`;
          report += `   Contracts: ${tx.raw_data?.contract?.length || 0}\n`;
        });
      }
    } else {
      report += `No data field found in response\n`;
    }
    
    console.log(report);
    showAlert("TRON Test Results", report);
    
  } catch (error) {
    console.error("‚ùå Error testing TRON wallet:", error);
    showAlert("TRON Test Error", `‚ùå TRON wallet test failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// UTILITY FUNCTIONS
// ===========================================

/**
 * Helper: Get sheet row count safely
 */
function getSheetRowCount(spreadsheet, sheetName) {
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    return sheet ? Math.max(0, sheet.getLastRow() - (sheetName.includes('FORMATTED') ? 1 : 6)) : 0;
  } catch (error) {
    return 0;
  }
}

// ===========================================
// BINANCE API PROCESSING (Apps Script)
// ===========================================

function processBinanceAPIs() {
  try {
    console.log("üîß Processing Binance APIs from Apps Script...");
    
    // Read API credentials from Settings sheet
    const apiCredentials = readApiCredentialsFromSheet();
    
    const binanceAccounts = [
      {
        name: "Binance (GC)",
        apiKey: apiCredentials.BINANCE_GC_API?.apiKey || '',
        apiSecret: apiCredentials.BINANCE_GC_API?.apiSecret || ''
      },
      {
        name: "Binance (Main)",
        apiKey: apiCredentials.BINANCE_MAIN_API?.apiKey || '',
        apiSecret: apiCredentials.BINANCE_MAIN_API?.apiSecret || ''
      },
      {
        name: "Binance (CV)",
        apiKey: apiCredentials.BINANCE_CV?.apiKey || '',
        apiSecret: apiCredentials.BINANCE_CV?.apiSecret || ''
      }
    ];

    let allTransactions = [];
    
    for (const account of binanceAccounts) {
      if (!account.apiKey || !account.apiSecret) {
        console.log(`‚ö†Ô∏è ${account.name}: Missing API credentials`);
        continue;
      }

      console.log(`üîß Processing ${account.name} with credentials...`);
      const result = processBinanceAccount(account);
      
      if (result.success) {
        allTransactions.push(...result.transactions);
        console.log(`‚úÖ ${account.name}: ${result.transactions.length} transactions`);
      } else {
        console.log(`‚ùå ${account.name}: ${result.error}`);
      }
    }

    console.log(`üìä Total Binance transactions: ${allTransactions.length}`);
    return allTransactions;
    
  } catch (error) {
    console.error("‚ùå Error processing Binance APIs:", error);
    return [];
  }
}

function readApiCredentialsFromSheet() {
  try {
    console.log('üîë Reading API credentials from Settings sheet...');
    
    const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    const apiKeysRange = 'K3:M7'; // Skip header row, read data rows
    const apiKeysData = sheet.getRange(apiKeysRange).getValues();
    
    const credentials = {};
    
    apiKeysData.forEach(row => {
      if (row[0] && row[1] && row[2]) {
        const platform = row[0]; // Column K
        const apiKey = row[1];   // Column L
        const apiSecret = row[2]; // Column M
        
        credentials[platform] = {
          apiKey: apiKey,
          apiSecret: apiSecret
        };
        console.log(`‚úÖ Loaded credentials for ${platform}`);
      }
    });
    
    console.log(`üìä Loaded ${Object.keys(credentials).length} API credential sets`);
    return credentials;
    
  } catch (error) {
    console.error('‚ùå Error reading API credentials from sheet:', error);
    return {};
  }
}

function processBinanceAccount(account) {
  try {
    console.log(`üîß Processing ${account.name}...`);
    
    // For now, return empty result since Apps Script has limitations with crypto APIs
    // In a real implementation, you would need to use external services or different approach
    console.log(`‚ö†Ô∏è ${account.name}: Apps Script has limitations with crypto APIs`);
    
    return {
      success: false,
      transactions: [],
      error: "Apps Script has limitations with crypto APIs - needs external service"
    };
    
  } catch (error) {
    return {
      success: false,
      transactions: [],
      error: error.message
    };
  }
}

// ===========================================
// MAIN EXECUTION & WORKFLOW
// ===========================================