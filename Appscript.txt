/**
 * COMPLETE ENHANCED Apps Script for Vercel Mode with Custom Menu
 * Includes testing features and professional menu system
 *
 * FINAL TIMESTAMP FIX: Adjusts all timestamps by +4h during data processing.
 */

const CONFIG = {
  SHEET_ID: "1sx3ik8I-2_VcD3X1q6M4kOuo3hfkGbMa1JulPSWID9Y",
  FORMATTED_SHEET: "FORMATTED_TRANSACTIONS",
  WITHDRAWALS_SHEET: "Withdrawals",
  DEPOSITS_SHEET: "Deposits",
  SETTINGS_SHEET: "SETTINGS",
  VERCEL_CRYPTO_ENDPOINT: "https://zaid-v2-darshanas-projects-d30d0377.vercel.app/api/crypto-to-sheets"
};

// ===========================================
// TIMESTAMP ADJUSTMENT FUNCTION
// ===========================================

/**
 * Adjusts a timestamp string or Date object by +2 hours and ensures 24h format.
 * Handles date-only strings by adding time information.
 * @param {Date|string} timestamp The original timestamp.
 * @returns {Date} The adjusted Date object with proper time format.
 */
function adjustTimestampToGST(timestamp) {
  try {
    if (!timestamp) return new Date();

    let date;
    
    // Handle different timestamp formats
    if (typeof timestamp === 'string') {
      // If it's just a date (YYYY-MM-DD or DD/MM/YYYY format)
      if (timestamp.match(/^\d{4}-\d{2}-\d{2}$/) || timestamp.match(/^\d{1,2}\/\d{1,2}\/\d{4}$/)) {
        // Add time component (00:00:00) to make it a full datetime
        const dateOnly = timestamp.replace(/\//g, '-'); // Convert DD/MM/YYYY to YYYY-MM-DD if needed
        date = new Date(dateOnly + 'T00:00:00Z');
      } else if (!timestamp.endsWith('Z')) {
        // If it has time but no Z, add Z to treat as UTC
        date = new Date(timestamp.replace(' ', 'T') + 'Z');
      } else {
        // Already has Z, parse as is
        date = new Date(timestamp);
      }
    } else {
      // It's already a Date object
      date = new Date(timestamp);
    }
      
    // Add 2 hours
    date.setHours(date.getHours() + 2);
    
    return date;
  } catch (error) {
    console.error(`‚ùå Error adjusting timestamp "${timestamp}":`, error);
    return (timestamp instanceof Date) ? timestamp : new Date();
  }
}

// ===========================================
// MAIN EXECUTION & WORKFLOW
// ===========================================

function mainVercelMode() {
  try {
    console.log("üöÄ Starting Vercel-mode crypto data fetch...");
    const settings = getSettingsConfiguration();
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);

    // Track last rows BEFORE fetching new data
    const withdrawalsSheet = spreadsheet.getSheetByName(CONFIG.WITHDRAWALS_SHEET);
    const depositsSheet = spreadsheet.getSheetByName(CONFIG.DEPOSITS_SHEET);
    const lastWithdrawalRow = withdrawalsSheet.getLastRow();
    const lastDepositRow = depositsSheet.getLastRow();

    // Step 1: Trigger Vercel to fetch and write raw data
    console.log("üì° Triggering Vercel data fetch...");
    const vercelResult = triggerVercelDataFetch(settings);

    // Step 2: Update the API status table in Settings with adjusted timestamps
    if (vercelResult && vercelResult.apiStatus) {
      updateApiStatusTable(vercelResult.apiStatus);
    }

    // Step 3: Adjust timestamps ONLY for new rows
    adjustTimestampsForNewRows(spreadsheet, CONFIG.WITHDRAWALS_SHEET, lastWithdrawalRow);
    adjustTimestampsForNewRows(spreadsheet, CONFIG.DEPOSITS_SHEET, lastDepositRow);

    // Step 4: Consolidate data into the final formatted sheet
    console.log("üîÑ Consolidating to formatted sheet...");
    consolidateToFormatted();
    
    // Step 5: Update the 'Last Execution' timestamp in Settings
    console.log("‚è∞ Updating last execution timestamp...");
    updateLastExecutionTime();
    
    console.log("‚úÖ Vercel-mode flow completed successfully.");
    showAlert("Success", "‚úÖ Main extraction completed successfully! Only new timestamps have been adjusted.");
  } catch (error) {
    console.error("‚ùå FATAL ERROR in main workflow:", error);
    showAlert("Fatal Error", `‚ùå Main extraction failed!\n\nError: ${error.message}`);
  }
}

function adjustTimestampsForNewRows(spreadsheet, sheetName, prevLastRow) {
  const sheet = spreadsheet.getSheetByName(sheetName);
  const newLastRow = sheet.getLastRow();
  const startRow = prevLastRow + 1;
  if (newLastRow < startRow) return; // No new rows

  // Adjust timestamps and format as string
  const range = sheet.getRange(startRow, 9, newLastRow - startRow + 1, 1); // Column I
  const values = range.getValues();
  const adjusted = values.map(row => {
    const dateObj = adjustTimestampToGST(row[0]);
    // Format as "MM/dd/yyyy HH:mm:ss"
    return [Utilities.formatDate(dateObj, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "MM/dd/yyyy HH:mm:ss")];
  });
  range.setValues(adjusted);

  // Set number format for Amount column (H)
  const amountRange = sheet.getRange(startRow, 8, newLastRow - startRow + 1, 1);
  amountRange.setNumberFormat("0.00#######");

  // Set date-time format for Timestamp column (I)
  range.setNumberFormat("MM/dd/yyyy HH:mm:ss");

  console.log(`‚úÖ Adjusted timestamps and formats for new rows in "${sheetName}" (${startRow} to ${newLastRow}).`);
}

function triggerVercelDataFetch(settings) {
  try {
    console.log("üì° Triggering Vercel data fetch...");
    
    // Read API credentials from Settings sheet
    const apiCredentials = readApiCredentialsFromSheet();
    console.log("üîë Loaded API credentials:", Object.keys(apiCredentials));
    
    // Add detailed logging for Bitget credentials
    if (apiCredentials.BITGET_API) {
      console.log("üîç Bitget credentials found:");
      console.log("   - API Key:", apiCredentials.BITGET_API.apiKey ? "‚úÖ Present" : "‚ùå Missing");
      console.log("   - API Secret:", apiCredentials.BITGET_API.apiSecret ? "‚úÖ Present" : "‚ùå Missing");
      console.log("   - Key length:", apiCredentials.BITGET_API.apiKey ? apiCredentials.BITGET_API.apiKey.length : 0);
      console.log("   - Secret length:", apiCredentials.BITGET_API.apiSecret ? apiCredentials.BITGET_API.apiSecret.length : 0);
    } else {
      console.log("‚ö†Ô∏è Bitget credentials NOT found in apiCredentials object");
    }
    
    // Log all credential keys for debugging
    console.log("üîç All credential keys available:", Object.keys(apiCredentials));
    Object.keys(apiCredentials).forEach(key => {
      const cred = apiCredentials[key];
      console.log(`   - ${key}: ${cred.apiKey ? '‚úÖ' : '‚ùå'} Key, ${cred.apiSecret ? '‚úÖ' : '‚ùå'} Secret`);
    });
    
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      payload: JSON.stringify({
        action: "fetch_and_write",
        startDate: settings.startDate,
        apiCredentials: apiCredentials // Send credentials to Vercel
      }),
      muteHttpExceptions: true
    });
    
    const responseText = response.getContentText();
    const data = JSON.parse(responseText);

    if (data.debugLogs && Array.isArray(data.debugLogs)) {
      console.log("--- üì° Vercel Debug Logs Start üì° ---");
      data.debugLogs.forEach(log => console.log(log));
      console.log("--- üì° Vercel Debug Logs End üì° ---");
    }
    
    if (response.getResponseCode() !== 200) throw new Error(`Vercel API error: ${response.getResponseCode()} - ${responseText}`);
    if (!data.success) throw new Error(`Vercel process failed: ${data.error || 'Unknown error'}`);
    
    console.log(`‚úÖ Vercel processed ${data.transactions} transactions.`);
    return data;
  } catch (error) {
    console.error("‚ùå Error triggering Vercel:", error);
    throw error;
  }
}

/**
 * Format transaction sheet with proper number formatting
 */
function formatTransactionSheet(sheet, newRowsAdded) {
  try {
    const lastRow = sheet.getLastRow();
    const startRow = lastRow - newRowsAdded + 1;
    
    if (startRow <= lastRow) {
      // Format Amount column (H) with decimal places
      const amountRange = sheet.getRange(startRow, 8, newRowsAdded, 1);
      amountRange.setNumberFormat("0.00#######");
      
      // Format Amount AED column (B) with decimal places
      const aedRange = sheet.getRange(startRow, 2, newRowsAdded, 1);
      aedRange.setNumberFormat("0.00");
      
      // Format Rate column (D) with decimal places
      const rateRange = sheet.getRange(startRow, 4, newRowsAdded, 1);
      rateRange.setNumberFormat("0.00");
      
      // Format Timestamp column (I) with date-time format
      const timestampRange = sheet.getRange(startRow, 9, newRowsAdded, 1);
      timestampRange.setNumberFormat("MM/dd/yyyy HH:mm:ss");
      
      console.log(`‚úÖ Formatted ${newRowsAdded} rows in sheet`);
    }
  } catch (error) {
    console.error("‚ùå Error formatting sheet:", error);
  }
}

// ===========================================
// DATA CONSOLIDATION & FORMATTING
// ===========================================

function consolidateToFormatted() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    // Read from raw sheets and get the transaction data (NO adjustment here, just read)
    const withdrawals = readRawSheet(spreadsheet, CONFIG.WITHDRAWALS_SHEET, 'withdrawal');
    const deposits = readRawSheet(spreadsheet, CONFIG.DEPOSITS_SHEET, 'deposit');

    // Validate data processing
    validateDataProcessing(withdrawals, deposits);

    const allTransactions = [...withdrawals, ...deposits];
    
    // Improved sorting: handle both string and Date timestamps
    allTransactions.sort((a, b) => {
      const dateA = new Date(a.timestamp);
      const dateB = new Date(b.timestamp);
      return dateB - dateA; // Sort newest first
    });
    
    updateFormattedTransactionsSheet(spreadsheet, allTransactions);

    console.log(`‚úÖ Consolidated ${allTransactions.length} transactions (${withdrawals.length} withdrawals, ${deposits.length} deposits).`);
  } catch (error) {
    console.error("‚ùå Error in consolidateToFormatted:", error);
  }
}

function getSheetData(spreadsheet, sheetName) {
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() < 7) return [];
    return sheet.getRange(7, 1, sheet.getLastRow() - 6, 12).getValues();
}

function updateSheetWithAdjustedTimestamps(spreadsheet, sheetName, data) {
    if (data.length === 0) return;
    const sheet = spreadsheet.getSheetByName(sheetName);
    
    const adjustedData = data.map(row => {
        const timestamp = row[8]; // Column I is timestamp
        if (timestamp) {
            const adjustedDate = adjustTimestampToGST(timestamp);
            // --- FIX: Format to string to preserve date and time ---
            row[8] = Utilities.formatDate(adjustedDate, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "MM/dd/yyyy HH:mm:ss");
        }
        return row;
    });
    
    const dataRange = sheet.getRange(7, 1, adjustedData.length, 12);
    dataRange.setValues(adjustedData);

    // --- FIX: Explicitly set number format for Amount column (H) to preserve decimals ---
    const amountColumnIndex = 8; // Column H
    const amountRange = sheet.getRange(7, amountColumnIndex, adjustedData.length, 1);
    amountRange.setNumberFormat("0.00#######"); // A flexible format for crypto amounts

    console.log(`‚úÖ Adjusted timestamps and number formatting in "${sheetName}".`);
}

function readRawSheet(spreadsheet, sheetName, transactionType) {
  const transactions = [];
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() <= 6) return transactions;
    const data = sheet.getRange(7, 1, sheet.getLastRow() - 6, 12).getValues();
    
    data.forEach(row => {
      if (row[5] && row[6]) { // Platform and Asset must exist
        transactions.push({
          timestamp: row[8], // Read timestamp AS-IS
          platform: row[5], type: transactionType, asset: row[6],
          amount: row[7] || '0', amount_aed: row[1] || '0',
          rate: row[3] || '0', client: row[0] || '',
          remarks: row[4] || '', from_address: row[9] || '',
          to_address: row[10] || '', tx_id: row[11] || '',
        });
      }
    });
  } catch (error) { console.error(`‚ùå Error reading ${sheetName}:`, error); }
  return transactions;
}

function updateFormattedTransactionsSheet(spreadsheet, transactions) {
  try {
    const sheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    if (!sheet) throw new Error("FORMATTED_TRANSACTIONS sheet not found");

    // Clear existing data (keep header row)
    if (sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    }
    if (transactions.length === 0) {
      console.log("‚ÑπÔ∏è No transactions to format");
      return;
    }

    const formattedRows = transactions.map(tx => {
      try {
        const rate = parseFloat(tx.rate) || getCryptoRate(tx.asset);
        const amount = parseFloat(tx.amount) || 0;
        const aedValue = parseFloat(tx.amount_aed) || (amount * rate);
        
        // Format timestamp properly
        let formattedTimestamp = tx.timestamp;
        if (tx.timestamp) {
          const date = new Date(tx.timestamp);
          if (!isNaN(date.getTime())) {
            formattedTimestamp = Utilities.formatDate(date, SpreadsheetApp.getActive().getSpreadsheetTimeZone(), "MM/dd/yyyy HH:mm:ss");
          }
        }
        
        return [
          formattedTimestamp, 
          tx.platform || '', 
          tx.type.charAt(0).toUpperCase() + tx.type.slice(1),
          tx.asset || '', 
          amount.toFixed(8), 
          `AED ${aedValue.toLocaleString()}`,
          rate.toFixed(2), 
          tx.client || '', 
          tx.remarks || '', 
          tx.from_address || '',
          tx.to_address || '', 
          tx.tx_id || ''
        ];
      } catch (error) {
        console.error(`‚ùå Error formatting transaction:`, tx, error);
        // Return a safe default row
        return [
          tx.timestamp || '', 
          tx.platform || '', 
          tx.type || '', 
          tx.asset || '', 
          '0.00000000', 
          'AED 0',
          '0.00', 
          tx.client || '', 
          tx.remarks || '', 
          tx.from_address || '',
          tx.to_address || '', 
          tx.tx_id || ''
        ];
      }
    });
    
    // Write data to sheet
    sheet.getRange(2, 1, formattedRows.length, 12).setValues(formattedRows);
    
    // Apply formatting
    if (formattedRows.length > 0) {
      // Format Amount column (E) with 8 decimal places
      sheet.getRange(2, 5, formattedRows.length, 1).setNumberFormat("0.00000000");
      // Format AED Value column (F) 
      sheet.getRange(2, 6, formattedRows.length, 1).setNumberFormat("@");
      // Format Rate column (G) with 2 decimal places
      sheet.getRange(2, 7, formattedRows.length, 1).setNumberFormat("0.00");
      // Format Timestamp column (A) with date-time format
      sheet.getRange(2, 1, formattedRows.length, 1).setNumberFormat("MM/dd/yyyy HH:mm:ss");
    }
    
    console.log(`‚úÖ Updated FORMATTED_TRANSACTIONS with ${formattedRows.length} transactions`);
  } catch (error) {
    console.error("‚ùå Error updating FORMATTED_TRANSACTIONS:", error);
  }
}

// ===========================================
// SETTINGS SHEET MANAGEMENT
// ===========================================

function getSettingsConfiguration() {
  try {
    const settingsSheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    const startDate = new Date(settingsSheet.getRange('H13').getValue()).toISOString();
    return { startDate };
  } catch (e) {
    return { startDate: new Date('2025-01-01').toISOString() };
  }
}

function updateLastExecutionTime() {
  try {
    const settingsSheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    settingsSheet.getRange('H16').setValue(new Date()); // Remove adjustment - use actual time
  } catch (error) {
    console.error("‚ùå Error updating last execution time:", error);
  }
}

function updateApiStatusTable(apiStatus) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    if (!sheet) return;
    
    const statusRows = Object.entries(apiStatus).map(([platform, status]) => [
        platform,
        status.status,
        status.lastSync, // Remove adjustment - use actual sync time
        status.autoUpdate,
        status.notes
    ]);

    if (statusRows.length > 0) {
      sheet.getRange('A3:E20').clearContent();
      sheet.getRange(3, 1, statusRows.length, statusRows[0].length).setValues(statusRows);
      console.log(`‚úÖ Updated ${statusRows.length} API statuses in Settings.`);
    }
    
    // Update wallet statuses in the DECENTRALIZED WALLETS table
    updateWalletStatuses(apiStatus);
  } catch (error) {
    console.error("‚ùå Error updating API status:", error);
  }
}

// ===========================================
// NEW: WALLET STATUS UPDATER FOR DECENTRALIZED WALLETS
// ===========================================

function updateWalletStatuses(apiStatus) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.SHEET_ID).getSheetByName(CONFIG.SETTINGS_SHEET);
    if (!sheet) return;
    
    // Read the current wallet table (T3:X17)
    const walletRange = sheet.getRange('T3:X17');
    const walletData = walletRange.getValues();
    
    // Update statuses based on apiStatus
    for (let i = 0; i < walletData.length; i++) {
      const row = walletData[i];
      const walletName = row[0]; // Column T - Name
      const walletAddress = row[1]; // Column U - Address
      const blockchainType = row[2]; // Column V - Blockchain Type
      const apiKey = row[3]; // Column W - API Key
      const currentStatus = row[4]; // Column X - Status
      
      // Only update if wallet has an address and blockchain type
      if (walletName && walletAddress && blockchainType) {
        // Check if this wallet exists in apiStatus
        if (apiStatus[walletName]) {
          const newStatus = apiStatus[walletName].status;
          // Update the status cell (Column X)
          sheet.getRange(3 + i, 24).setValue(newStatus); // Column X is 24th column
          console.log(`‚úÖ Updated ${walletName} status to: ${newStatus}`);
        }
      }
    }
    
    console.log("‚úÖ Updated wallet statuses in DECENTRALIZED WALLETS table");
  } catch (error) {
    console.error("‚ùå Error updating wallet statuses:", error);
  }
}

// ===========================================
// UTILITIES 
// ===========================================

function getCryptoRate(asset) {
  const rates = {'BTC': 220200, 'ETH': 11010, 'USDT': 3.67, 'USDC': 3.67, 'SOL': 550, 'TRX': 0.37, 'BNB': 2200, 'SEI': 1.47};
  return rates[asset] || 1;
}

function showAlert(title, message) {
  try {
    const ui = SpreadsheetApp.getUi();
    ui.alert(title, message, ui.ButtonSet.OK);
  } catch (error) {
    // Fallback to console if UI not available
    console.log(`${title}: ${message}`);
  }
}

// ===========================================
// CUSTOM MENU SYSTEM
// ===========================================

/**
 * Create custom CryptoWallet menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('üöÄ Crypto Wallet')
    .addItem('üìä Main Extraction', 'mainVercelMode')
    .addSeparator()
    .addSubMenu(ui.createMenu('üß™ Test Functions')
      .addItem('ÔøΩÔøΩ Test Last Week', 'testLastWeekExtraction')
      .addItem('üìÖ Test 30 Days', 'testSpecificDateRange')
      .addItem('üîó Test Connection', 'testVercelConnection')
      .addItem('üìä Count Transactions', 'countCurrentTransactions')
      .addItem('üìà Test Sheet Access', 'testSheetAccess')
      .addItem('üü¢ Test TRON Wallet', 'testTronWallet'))
    .addSeparator()
    .addItem('üìñ User Guide', 'showUserGuide')
    .addToUi();
    
  console.log("‚úÖ CryptoWallet menu created successfully");
}

/**
 * Shows a comprehensive user guide with instructions and data explanations
 */
function showUserGuide() {
  const guide = `
üöÄ CRYPTO WALLET - USER GUIDE

üìä MAIN EXTRACTION:
‚Ä¢ Click "üìä Main Extraction" to start the automated data fetch
‚Ä¢ The system will fetch data from multiple crypto exchange APIs and update your sheets
‚Ä¢ All transaction timestamps are automatically adjusted to your local timezone

üìã WHAT DATA IS UPDATED:

1Ô∏è‚É£ WITHDRAWALS SHEET (Column I - Timestamps):
‚Ä¢ Binance P2P sell transactions
‚Ä¢ Binance Pay withdrawal transactions
‚Ä¢ Binance Spot trading withdrawals
‚Ä¢ Binance Futures withdrawals
‚Ä¢ Bybit P2P sell transactions
‚Ä¢ Bybit Spot trading withdrawals
‚Ä¢ Bybit Futures withdrawals
‚Ä¢ Other wallet withdrawal transactions

2Ô∏è‚É£ DEPOSITS SHEET (Column I - Timestamps):
‚Ä¢ Binance P2P buy transactions  
‚Ä¢ Binance Pay deposit transactions
‚Ä¢ Binance Spot trading deposits
‚Ä¢ Binance Futures deposits
‚Ä¢ Bybit P2P buy transactions
‚Ä¢ Bybit Spot trading deposits
‚Ä¢ Bybit Futures deposits
‚Ä¢ Other wallet deposit transactions

3Ô∏è‚É£ FORMATTED_TRANSACTIONS SHEET (Column A - Timestamps):
‚Ä¢ Consolidated view of all transactions from all platforms
‚Ä¢ Sorted by timestamp (newest first)
‚Ä¢ Complete transaction history across all exchanges

4Ô∏è‚É£ SETTINGS SHEET:
‚Ä¢ API Status Table: Shows which platforms are working
‚Ä¢ Last Sync times: When each API was last checked
‚Ä¢ Last Execution: When the main extraction was last run
‚Ä¢ Start Date: Date from which to fetch transactions

üîÑ AUTOMATED PROCESS:
1. Fetches data from multiple crypto exchange APIs
2. Writes to Withdrawals/Deposits sheets
3. Adjusts all timestamps to local timezone
4. Consolidates data to FORMATTED_TRANSACTIONS
5. Updates Settings with status information

üìä DATA SOURCES & TRANSACTION TYPES:

BINANCE:
‚Ä¢ P2P (Peer-to-Peer) transactions
‚Ä¢ Pay (Direct Pay) transactions
‚Ä¢ Spot trading transactions
‚Ä¢ Futures trading transactions
‚Ä¢ Staking rewards
‚Ä¢ Mining rewards

BYBIT:
‚Ä¢ P2P (Peer-to-Peer) transactions
‚Ä¢ Spot trading transactions
‚Ä¢ Futures trading transactions
‚Ä¢ Options trading transactions
‚Ä¢ Copy trading transactions

OTHER WALLETS:
‚Ä¢ External wallet transfers
‚Ä¢ DeFi protocol transactions
‚Ä¢ NFT marketplace transactions
‚Ä¢ Staking platform transactions

üîç TRANSACTION FILTERING:
‚Ä¢ Automatic filtering of small amounts/fees
‚Ä¢ Duplicate transaction detection
‚Ä¢ Invalid transaction removal
‚Ä¢ Transaction charge separation to RecycleBin

Need help? Check the execution logs for detailed information about the process.
`;

  try {
    SpreadsheetApp.getUi().alert('üìñ User Guide', guide, SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (e) {
    console.log('User Guide:\n' + guide);
  }
}

// ===========================================
// QUICK TEST FUNCTIONS
// ===========================================

/**
 * TEST: Vercel endpoint connection
 */
function testVercelConnection() {
  try {
    console.log("üß™ Testing Vercel connection...");
    
    const testPayload = {
      action: "test_connection",
      timestamp: new Date().toISOString()
    };
    
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(testPayload),
      muteHttpExceptions: true
    });
    
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (statusCode === 200) {
      console.log("‚úÖ Vercel connection successful");
      showAlert("Success", "‚úÖ Vercel connection working perfectly!\n\nResponse: " + responseText.substring(0, 200) + "...");
    } else {
      console.error(`‚ùå Vercel connection failed: ${statusCode}`);
      showAlert("Error", `‚ùå Vercel connection failed!\n\nStatus: ${statusCode}\nResponse: ${responseText.substring(0, 200)}...`);
    }
    
  } catch (error) {
    console.error("‚ùå Error testing Vercel connection:", error);
    showAlert("Error", `‚ùå Connection test failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Count transactions in current sheets
 */
function countCurrentTransactions() {
  try {
    console.log("üîç Counting current transactions...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Count withdrawals
    const withdrawalsSheet = spreadsheet.getSheetByName(CONFIG.WITHDRAWALS_SHEET);
    const withdrawalsCount = withdrawalsSheet ? Math.max(0, withdrawalsSheet.getLastRow() - 6) : 0;
    
    // Count deposits  
    const depositsSheet = spreadsheet.getSheetByName(CONFIG.DEPOSITS_SHEET);
    const depositsCount = depositsSheet ? Math.max(0, depositsSheet.getLastRow() - 6) : 0;
    
    // Count formatted transactions
    const formattedSheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    const formattedCount = formattedSheet ? Math.max(0, formattedSheet.getLastRow() - 1) : 0;
    
    const report = `üìä Transaction Count Report:

üì§ Withdrawals: ${withdrawalsCount}
üì• Deposits: ${depositsCount}
üìà Total Raw: ${withdrawalsCount + depositsCount}
üìã Formatted: ${formattedCount}

üìÖ Last Update: ${new Date().toLocaleString()}`;

    console.log(report);
    showAlert("Transaction Count", report);
    
  } catch (error) {
    console.error("‚ùå Error counting transactions:", error);
    showAlert("Error", `‚ùå Count failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Sheet access and structure
 */
function testSheetAccess() {
  try {
    console.log("üìà Testing sheet access...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheets = spreadsheet.getSheets();
    
    let report = "üìä Sheet Access Test:\n\n";
    
    // Check each required sheet
    const requiredSheets = [CONFIG.WITHDRAWALS_SHEET, CONFIG.DEPOSITS_SHEET, CONFIG.FORMATTED_SHEET, CONFIG.SETTINGS_SHEET];
    
    requiredSheets.forEach(sheetName => {
      const sheet = spreadsheet.getSheetByName(sheetName);
      if (sheet) {
        report += `‚úÖ ${sheetName}: ${sheet.getLastRow()} rows\n`;
      } else {
        report += `‚ùå ${sheetName}: Missing!\n`;
      }
    });
    
    report += `\nüìã Total Sheets: ${sheets.length}`;
    
    console.log(report);
    showAlert("Sheet Access", report);
    
  } catch (error) {
    console.error("‚ùå Error testing sheet access:", error);
    showAlert("Error", `‚ùå Sheet test failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// SYSTEM TOOLS
// ===========================================

/**
 * Delete all existing triggers
 */
function deleteAllTriggers() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    
    if (triggers.length === 0) {
      showAlert("Info", "‚ÑπÔ∏è No triggers found to delete.");
      return;
    }
    
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    console.log(`üóëÔ∏è Deleted ${triggers.length} triggers`);
    showAlert("Success", `‚úÖ Deleted ${triggers.length} triggers successfully!`);
    
  } catch (error) {
    console.error("‚ùå Error deleting triggers:", error);
    showAlert("Error", `‚ùå Failed to delete triggers!\n\nError: ${error.message}`);
  }
}

/**
 * Show comprehensive system status
 */
function showSystemStatus() {
  try {
    console.log("üìã Generating system status...");
    
    const triggers = ScriptApp.getProjectTriggers();
    const settings = getSettingsConfiguration();
    
    let status = "üîç CryptoWallet System Status:\n\n";
    
    // Triggers status
    status += "‚öôÔ∏è TRIGGERS:\n";
    if (triggers.length === 0) {
      status += "‚ùå No triggers active\n";
    } else {
      triggers.forEach(trigger => {
        status += `‚úÖ ${trigger.getHandlerFunction()}: ${trigger.getTriggerSource()}\n`;
      });
    }
    
    // Settings status
    status += "\nüìÖ SETTINGS:\n";
    status += `Start Date: ${settings.startDate}\n`;
    status += `Last Execution: ${settings.lastExecution || 'Never'}\n`;
    
    // Sheet status
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    status += "\nüìä SHEETS:\n";
    status += `Withdrawals: ${getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET)} rows\n`;
    status += `Deposits: ${getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET)} rows\n`;
    status += `Formatted: ${getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET)} rows\n`;
    
    status += `\n‚è∞ Generated: ${new Date().toLocaleString()}`;
    
    console.log(status);
    showAlert("System Status", status);
    
  } catch (error) {
    console.error("‚ùå Error generating system status:", error);
    showAlert("Error", `‚ùå Status check failed!\n\nError: ${error.message}`);
  }
}

/**
 * Export diagnostics to new sheet
 */
function exportDiagnostics() {
  try {
    console.log("üìä Exporting diagnostics...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Create or get diagnostics sheet
    let diagnosticsSheet;
    try {
      diagnosticsSheet = spreadsheet.getSheetByName("DIAGNOSTICS");
    } catch (e) {
      diagnosticsSheet = spreadsheet.insertSheet("DIAGNOSTICS");
    }
    
    // Clear existing data
    diagnosticsSheet.clear();
    
    // Create diagnostics report
    const timestamp = new Date();
    const settings = getSettingsConfiguration();
    const triggers = ScriptApp.getProjectTriggers();
    
    const diagnosticsData = [
      ["CryptoWallet System Diagnostics", "", ""],
      ["Generated At:", timestamp.toLocaleString(), ""],
      ["", "", ""],
      ["CONFIGURATION", "", ""],
      ["Sheet ID:", CONFIG.SHEET_ID, ""],
      ["Vercel Endpoint:", CONFIG.VERCEL_CRYPTO_ENDPOINT, ""],
      ["", "", ""],
      ["SETTINGS", "", ""],
      ["Start Date:", settings.startDate, ""],
      ["Last Execution:", settings.lastExecution || "Never", ""],
      ["", "", ""],
      ["TRIGGERS", "", ""],
      ["Active Triggers:", triggers.length, ""],
      ...triggers.map(t => ["Trigger:", t.getHandlerFunction(), t.getTriggerSource()]),
      ["", "", ""],
      ["SHEET STATISTICS", "", ""],
      ["Withdrawals Rows:", getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET), ""],
      ["Deposits Rows:", getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET), ""],
      ["Formatted Rows:", getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET), ""]
    ];
    
    // Write data to sheet
    diagnosticsSheet.getRange(1, 1, diagnosticsData.length, 3).setValues(diagnosticsData);
    
    // Format the sheet
    diagnosticsSheet.getRange("A1").setFontWeight("bold").setFontSize(14);
    diagnosticsSheet.getRange("A:A").setFontWeight("bold");
    diagnosticsSheet.autoResizeColumns(1, 3);
    
    console.log("‚úÖ Diagnostics exported successfully");
    showAlert("Success", "‚úÖ Diagnostics exported to DIAGNOSTICS sheet!");
    
  } catch (error) {
    console.error("‚ùå Error exporting diagnostics:", error);
    showAlert("Error", `‚ùå Export failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST FUNCTION: Check Settings date configuration
 */
function testDateSettings() {
  try {
    const settings = getSettingsConfiguration();
    
    let report = "üìÖ Date Settings Check:\n\n";
    report += `Start Date: ${settings.startDate}\n`;
    report += `Last Execution: ${settings.lastExecution || 'Never'}\n\n`;
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    report += "üìä Raw Settings Values:\n";
    report += `H13 (Start Date): ${settingsSheet.getRange('H13').getValue()}\n`;
    report += `H16 (Last Execution): ${settingsSheet.getRange('H16').getValue()}`;
    
    console.log(report);
    showAlert("Date Settings", report);
    
  } catch (error) {
    console.error("‚ùå Error testing date settings:", error);
    showAlert("Error", `‚ùå Date settings test failed!\n\nError: ${error.message}`);
  }
}

/**
 * UTILITY: Setup date controls in Settings if missing
 */
function setupDateControls() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      showAlert("Error", "‚ùå Settings sheet not found!");
      return;
    }
    
    // Add date control labels and default values
    settingsSheet.getRange('G13').setValue('Start Date:').setFontWeight('bold');
    settingsSheet.getRange('H13').setValue(new Date('2025-05-31')); // Updated default
    
    settingsSheet.getRange('G16').setValue('Last Execution:').setFontWeight('bold');
    settingsSheet.getRange('H16').setValue('Not executed yet');
    
    // Format date cells
    settingsSheet.getRange('H13').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    settingsSheet.getRange('H16').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    
    console.log("‚úÖ Date controls set up in Settings sheet");
    showAlert("Success", "‚úÖ Date controls set up successfully!\n\nüìÖ Start Date: 2025-05-31\nüìÖ Last Execution will be updated automatically");
    
  } catch (error) {
    console.error("‚ùå Error setting up date controls:", error);
    showAlert("Error", `‚ùå Date controls setup failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// TEST FUNCTIONS FOR DEBUGGING
// ===========================================

function testLastWeekExtraction() {
  try {
    console.log("üß™ Starting LAST WEEK test extraction...");
    
    // Calculate last week's date range
    const now = new Date();
    const lastWeekStart = new Date(now);
    lastWeekStart.setDate(now.getDate() - 7);
    
    const startDate = lastWeekStart.toISOString();
    const endDate = now.toISOString();
    
    console.log(`üìÖ Test period: ${startDate} to ${endDate}`);
    
    const settings = {
      startDate: startDate,
      testMode: true
    };
    
    // Trigger Vercel with last week's date
    console.log("üì° Triggering Vercel test fetch for last week...");
    const vercelResult = triggerVercelDataFetch(settings);
    
    if (vercelResult && vercelResult.debugLogs) {
      console.log("--- üß™ TEST Debug Logs Start üß™ ---");
      vercelResult.debugLogs.forEach(log => console.log(log));
      console.log("--- üß™ TEST Debug Logs End üß™ ---");
    }
    
    console.log("üß™ Test extraction completed:", vercelResult);
    showAlert("Test Complete", `üß™ Last week test extraction completed!\n\nPeriod: ${startDate} to ${endDate}\n\nCheck execution logs for details.`);
    
  } catch (error) {
    console.error("‚ùå Error in test extraction:", error);
    showAlert("Test Error", `‚ùå Test extraction failed!\n\nError: ${error.message}`);
  }
}

function testSpecificDateRange() {
  try {
    // Test with a specific date range (last 30 days)
    const now = new Date();
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(now.getDate() - 30);
    
    const startDate = thirtyDaysAgo.toISOString();
    
    console.log(`üß™ Testing 30-day range: ${startDate} to ${now.toISOString()}`);
    
    const settings = {
      startDate: startDate,
      testMode: true
    };
    
    const vercelResult = triggerVercelDataFetch(settings);
    
    if (vercelResult && vercelResult.debugLogs) {
      console.log("--- üß™ 30-DAY TEST Debug Logs Start üß™ ---");
      vercelResult.debugLogs.forEach(log => console.log(log));
      console.log("--- üß™ 30-DAY TEST Debug Logs End üß™ ---");
    }
    
    console.log("üß™ 30-day test completed:", vercelResult);
    showAlert("30-Day Test Complete", `üß™ 30-day test extraction completed!\n\nPeriod: ${startDate} to ${now.toISOString()}\n\nCheck execution logs for details.`);
    
  } catch (error) {
    console.error("‚ùå Error in 30-day test:", error);
    showAlert("Test Error", `‚ùå 30-day test failed!\n\nError: ${error.message}`);
  }
}

function testTronWallet() {
  try {
    console.log("üß™ Testing TRON wallet API...");
    
    const tronAddress = "TAUDuQAZSTUH88xno1imPoKN25eJN6aJkN";
    const endpoint = `https://api.trongrid.io/v1/accounts/${tronAddress}/transactions?limit=50&order_by=block_timestamp,desc`;
    
    console.log(`üîó Testing TRON API endpoint: ${endpoint}`);
    
    const response = UrlFetchApp.fetch(endpoint, {
      muteHttpExceptions: true
    });
    
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    console.log(`üì° TRON API Response Status: ${statusCode}`);
    console.log(`üìä TRON API Response: ${responseText.substring(0, 500)}...`);
    
    if (statusCode !== 200) {
      throw new Error(`TRON API error: ${statusCode} - ${responseText}`);
    }
    
    const data = JSON.parse(responseText);
    
    let report = `üß™ TRON Wallet Test Results:\n\n`;
    report += `Address: ${tronAddress}\n`;
    report += `Status Code: ${statusCode}\n`;
    report += `Has Data: ${!!data.data}\n`;
    
    if (data.data) {
      report += `Raw Transactions: ${data.data.length}\n\n`;
      
      // Test processing logic
      const filterDate = new Date();
      filterDate.setDate(filterDate.getDate() - 7);
      
      let validTransactions = 0;
      let transferContracts = 0;
      
      data.data.forEach((tx, index) => {
        const txDate = new Date(tx.block_timestamp);
        if (txDate >= filterDate) {
          validTransactions++;
          
          if (tx.raw_data && tx.raw_data.contract) {
            tx.raw_data.contract.forEach(contract => {
              if (contract.type === "TransferContract") {
                transferContracts++;
              }
            });
          }
        }
      });
      
      report += `Transactions in last 7 days: ${validTransactions}\n`;
      report += `Transfer contracts found: ${transferContracts}\n`;
      
      // Show first few transactions
      if (data.data.length > 0) {
        report += `\nüìã Sample Transactions:\n`;
        data.data.slice(0, 3).forEach((tx, index) => {
          const txDate = new Date(tx.block_timestamp);
          report += `${index + 1}. ${tx.txID}\n`;
          report += `   Date: ${txDate.toISOString()}\n`;
          report += `   Contracts: ${tx.raw_data?.contract?.length || 0}\n`;
        });
      }
    } else {
      report += `No data field found in response\n`;
    }
    
    console.log(report);
    showAlert("TRON Test Results", report);
    
  } catch (error) {
    console.error("‚ùå Error testing TRON wallet:", error);
    showAlert("TRON Test Error", `‚ùå TRON wallet test failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Check where API credentials are stored
 */
function testCredentialLocations() {
  try {
    console.log("üîç Testing credential locations...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      console.log("‚ùå Settings sheet not found");
      return;
    }
    
    console.log("üìä Checking various cell locations for credentials...");
    
    // Check common locations
    const locations = [
      { row: 25, col: 'B', desc: 'B25 (Binance GC Key)' },
      { row: 25, col: 'C', desc: 'C25 (Binance GC Secret)' },
      { row: 26, col: 'B', desc: 'B26 (Binance Main Key)' },
      { row: 26, col: 'C', desc: 'C26 (Binance Main Secret)' },
      { row: 27, col: 'B', desc: 'B27 (Binance CV Key)' },
      { row: 27, col: 'C', desc: 'C27 (Binance CV Secret)' },
      { row: 28, col: 'B', desc: 'B28 (ByBit Key)' },
      { row: 28, col: 'C', desc: 'C28 (ByBit Secret)' },
      // Check other possible locations
      { row: 20, col: 'B', desc: 'B20 (Alternative location)' },
      { row: 20, col: 'C', desc: 'C20 (Alternative location)' },
      { row: 30, col: 'B', desc: 'B30 (Alternative location)' },
      { row: 30, col: 'C', desc: 'C30 (Alternative location)' }
    ];
    
    locations.forEach(loc => {
      try {
        const value = settingsSheet.getRange(`${loc.col}${loc.row}`).getValue();
        if (value && value.toString().trim()) {
          console.log(`‚úÖ ${loc.desc}: "${value.toString().substring(0, 10)}..."`);
        } else {
          console.log(`‚ùå ${loc.desc}: Empty`);
        }
      } catch (e) {
        console.log(`‚ùå ${loc.desc}: Error - ${e.message}`);
      }
    });
    
    // Also check if there are any cells with "API" or "Key" in them
    console.log("üîç Searching for cells containing 'API' or 'Key'...");
    const dataRange = settingsSheet.getDataRange();
    const allData = dataRange.getValues();
    
    for (let row = 0; row < allData.length; row++) {
      for (let col = 0; col < allData[row].length; col++) {
        const cellValue = allData[row][col];
        if (cellValue && typeof cellValue === 'string') {
          if (cellValue.toLowerCase().includes('api') || 
              cellValue.toLowerCase().includes('key') || 
              cellValue.toLowerCase().includes('secret')) {
            console.log(`üîç Found potential credential cell at ${String.fromCharCode(65 + col)}${row + 1}: "${cellValue}"`);
          }
        }
      }
    }
    
  } catch (error) {
    console.error("‚ùå Error testing credential locations:", error);
  }
}

/**
 * SIMPLE: Find API credentials in Settings sheet
 */
function findApiCredentials() {
  try {
    console.log("üîç Searching for API credentials in Settings sheet...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      console.log("‚ùå Settings sheet not found");
      return;
    }
    
    // Get all data from the sheet
    const dataRange = settingsSheet.getDataRange();
    const allData = dataRange.getValues();
    
    console.log(`üìä Sheet has ${allData.length} rows and ${allData[0].length} columns`);
    
    // Search for cells containing API keys or secrets
    for (let row = 0; row < allData.length; row++) {
      for (let col = 0; col < allData[row].length; col++) {
        const cellValue = allData[row][col];
        if (cellValue && typeof cellValue === 'string') {
          const cellAddress = `${String.fromCharCode(65 + col)}${row + 1}`;
          
          // Check if this looks like an API key or secret
          if (cellValue.length > 20 && 
              (cellValue.toLowerCase().includes('binance') || 
               cellValue.toLowerCase().includes('bybit') ||
               cellValue.toLowerCase().includes('api') ||
               cellValue.toLowerCase().includes('key') ||
               cellValue.toLowerCase().includes('secret'))) {
            console.log(`üîë Found potential credential at ${cellAddress}: "${cellValue.substring(0, 20)}..."`);
          }
          
          // Also check for labels that might indicate credential locations
          if (cellValue.toLowerCase().includes('binance') || 
              cellValue.toLowerCase().includes('bybit') ||
              cellValue.toLowerCase().includes('api key') ||
              cellValue.toLowerCase().includes('secret')) {
            console.log(`üè∑Ô∏è Found credential label at ${cellAddress}: "${cellValue}"`);
          }
        }
      }
    }
    
    // Also check specific rows that might contain credentials
    console.log("üîç Checking specific rows for credentials...");
    for (let row = 20; row <= 35; row++) {
      for (let col = 0; col < 5; col++) { // Check columns A-E
        try {
          const cellAddress = `${String.fromCharCode(65 + col)}${row}`;
          const value = settingsSheet.getRange(cellAddress).getValue();
          if (value && value.toString().trim().length > 10) {
            console.log(`üìù ${cellAddress}: "${value.toString().substring(0, 15)}..."`);
          }
        } catch (e) {
          // Ignore errors for out-of-range cells
        }
      }
    }
    
  } catch (error) {
    console.error("‚ùå Error searching for credentials:", error);
  }
}

// ===========================================
// UTILITY FUNCTIONS
// ===========================================

/**
 * Helper: Get sheet row count safely
 */
function getSheetRowCount(spreadsheet, sheetName) {
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    return sheet ? Math.max(0, sheet.getLastRow() - (sheetName.includes('FORMATTED') ? 1 : 6)) : 0;
  } catch (error) {
    return 0;
  }
}

/**
 * Read API credentials from the Settings sheet
 * Returns an object with API credentials for different platforms
 */
function readApiCredentialsFromSheet() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      console.log("‚ùå Settings sheet not found");
      return {};
    }
    
    console.log("üîç Debugging credential reading...");
    
    const credentials = {};
    
    // Read Binance CV API credentials (row 3)
    try {
      const binanceCVKey = settingsSheet.getRange('L3').getValue();
      const binanceCVSecret = settingsSheet.getRange('M3').getValue();
      console.log(`üîç L3 (Binance CV Key): "${binanceCVKey}"`);
      console.log(`üîç M3 (Binance CV Secret): "${binanceCVSecret}"`);
      if (binanceCVKey && binanceCVSecret) {
        credentials.BINANCE_CV = {
          apiKey: binanceCVKey.toString(),
          apiSecret: binanceCVSecret.toString()
        };
        console.log("‚úÖ Loaded Binance CV credentials");
      } else {
        console.log("‚ö†Ô∏è Binance CV credentials empty or missing");
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Error reading Binance CV credentials:", e.message);
    }
    
    // Read Binance GC API credentials (row 4)
    try {
      const binanceGCKey = settingsSheet.getRange('L4').getValue();
      const binanceGCSecret = settingsSheet.getRange('M4').getValue();
      console.log(`üîç L4 (Binance GC Key): "${binanceGCKey}"`);
      console.log(`üîç M4 (Binance GC Secret): "${binanceGCSecret}"`);
      if (binanceGCKey && binanceGCSecret) {
        credentials.BINANCE_GC_API = {
          apiKey: binanceGCKey.toString(),
          apiSecret: binanceGCSecret.toString()
        };
        console.log("‚úÖ Loaded Binance GC credentials");
      } else {
        console.log("‚ö†Ô∏è Binance GC credentials empty or missing");
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Error reading Binance GC credentials:", e.message);
    }
    
    // Read Binance Main API credentials (row 5)
    try {
      const binanceMainKey = settingsSheet.getRange('L5').getValue();
      const binanceMainSecret = settingsSheet.getRange('M5').getValue();
      console.log(`üîç L5 (Binance Main Key): "${binanceMainKey}"`);
      console.log(`üîç M5 (Binance Main Secret): "${binanceMainSecret}"`);
      if (binanceMainKey && binanceMainSecret) {
        credentials.BINANCE_MAIN_API = {
          apiKey: binanceMainKey.toString(),
          apiSecret: binanceMainSecret.toString()
        };
        console.log("‚úÖ Loaded Binance Main credentials");
      } else {
        console.log("‚ö†Ô∏è Binance Main credentials empty or missing");
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Error reading Binance Main credentials:", e.message);
    }
    
    // Read ByBit API credentials (row 6)
    try {
      const bybitKey = settingsSheet.getRange('L6').getValue();
      const bybitSecret = settingsSheet.getRange('M6').getValue();
      console.log(`üîç L6 (ByBit Key): "${bybitKey}"`);
      console.log(`üîç M6 (ByBit Secret): "${bybitSecret}"`);
      if (bybitKey && bybitSecret) {
        credentials.BYBIT_API = {
          apiKey: bybitKey.toString(),
          apiSecret: bybitSecret.toString()
        };
        console.log("‚úÖ Loaded ByBit credentials");
      } else {
        console.log("‚ö†Ô∏è ByBit credentials empty or missing");
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Error reading ByBit credentials:", e.message);
    }
    
    // Read Bitget API credentials (row 8)
    try {
      const bitgetKey = settingsSheet.getRange('L8').getValue();
      const bitgetSecret = settingsSheet.getRange('M8').getValue();
      const bitgetPassphrase = settingsSheet.getRange('N8').getValue();
      console.log(`üîç L8 (Bitget Key): "${bitgetKey}"`);
      console.log(`üîç M8 (Bitget Secret): "${bitgetSecret}"`);
      console.log(`üîç N8 (Bitget Passphrase): "${bitgetPassphrase}"`);
      console.log(`üîç L8 cell type: ${typeof bitgetKey}, length: ${bitgetKey ? bitgetKey.length : 0}`);
      console.log(`üîç M8 cell type: ${typeof bitgetSecret}, length: ${bitgetSecret ? bitgetSecret.length : 0}`);
      console.log(`üîç N8 cell type: ${typeof bitgetPassphrase}, length: ${bitgetPassphrase ? bitgetPassphrase.length : 0}`);
      if (bitgetKey && bitgetSecret && bitgetPassphrase) {
        credentials.BITGET_API = {
          apiKey: bitgetKey.toString(),
          apiSecret: bitgetSecret.toString(),
          passphrase: bitgetPassphrase.toString().trim()  // Trim whitespace
        };
        console.log("‚úÖ Loaded Bitget credentials");
        console.log(`   - Key: ${bitgetKey.toString().substring(0, 10)}...`);
        console.log(`   - Secret: ${bitgetSecret.toString().substring(0, 10)}...`);
        console.log(`   - Passphrase (raw): "${bitgetPassphrase.toString()}"`);
        console.log(`   - Passphrase (trimmed): "${bitgetPassphrase.toString().trim()}"`);
      } else {
        console.log("‚ö†Ô∏è Bitget credentials empty or missing");
        console.log(`   - Key empty: ${!bitgetKey}`);
        console.log(`   - Secret empty: ${!bitgetSecret}`);
        console.log(`   - Passphrase empty: ${!bitgetPassphrase}`);
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Error reading Bitget credentials:", e.message);
    }
    
    console.log(`üîë Total credentials loaded: ${Object.keys(credentials).length}`);
    console.log(`üîë Credential keys: ${Object.keys(credentials).join(', ')}`);
    return credentials;
    
  } catch (error) {
    console.error("‚ùå Error reading API credentials:", error);
    return {};
  }
}

// ===========================================
// BINANCE API PROCESSING (Apps Script) - REMOVED
// Now handled by Vercel backend with credentials sent from Apps Script
// ===========================================

// ===========================================
// DATA VALIDATION & DEBUGGING
// ===========================================

/**
 * Validate and log data processing results
 */
function validateDataProcessing(withdrawals, deposits) {
  try {
    console.log("üîç Data Validation Results:");
    console.log(`üìä Withdrawals: ${withdrawals.length} transactions`);
    console.log(`üìä Deposits: ${deposits.length} transactions`);
    console.log(`üìä Total: ${withdrawals.length + deposits.length} transactions`);
    
    // Log sample transactions for debugging
    if (withdrawals.length > 0) {
      console.log("üì§ Sample Withdrawal:", {
        platform: withdrawals[0].platform,
        asset: withdrawals[0].asset,
        amount: withdrawals[0].amount,
        timestamp: withdrawals[0].timestamp
      });
    }
    
    if (deposits.length > 0) {
      console.log("üí∞ Sample Deposit:", {
        platform: deposits[0].platform,
        asset: deposits[0].asset,
        amount: deposits[0].amount,
        timestamp: deposits[0].timestamp
      });
    }
    
    // Check for data quality issues
    const issues = [];
    [...withdrawals, ...deposits].forEach((tx, index) => {
      if (!tx.platform || !tx.asset) {
        issues.push(`Transaction ${index}: Missing platform or asset`);
      }
      if (!tx.timestamp) {
        issues.push(`Transaction ${index}: Missing timestamp`);
      }
    });
    
    if (issues.length > 0) {
      console.log("‚ö†Ô∏è Data Quality Issues:", issues);
    } else {
      console.log("‚úÖ All transactions have required fields");
    }
    
  } catch (error) {
    console.error("‚ùå Error in data validation:", error);
  }
}