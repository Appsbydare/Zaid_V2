/**
 * COMPLETE ENHANCED Apps Script for Vercel Mode with Custom Menu
 * Includes testing features and professional menu system
 */

const CONFIG = {
  SHEET_ID: "1pLsxrfU5NgHF4aNLXNnCCvGgBvKO4EKjb44iiVvUp5Q",
  FORMATTED_SHEET: "FORMATTED_TRANSACTIONS",
  WITHDRAWALS_SHEET: "Withdrawals",
  DEPOSITS_SHEET: "Deposits",
  SETTINGS_SHEET: "SETTINGS",
  
  // Vercel endpoint for direct data writing
  VERCEL_CRYPTO_ENDPOINT: "https://zaid-cryptowallets.vercel.app/api/crypto-to-sheets"
};

// ===========================================
// CUSTOM MENU SYSTEM
// ===========================================

/**
 * Create custom CryptoWallet menu when spreadsheet opens
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  
  ui.createMenu('🚀 CryptoWallet')
    .addItem('⚡ Execute Main Extraction', 'mainVercelMode')
    .addSeparator()
    .addSubMenu(ui.createMenu('🧪 Quick Tests')
      .addItem('📡 Test Vercel Connection', 'testVercelConnection')
      .addItem('📊 Test Date Settings', 'testDateSettings')
      .addItem('📈 Test Sheet Access', 'testSheetAccess')
      .addItem('🔍 Count Current Transactions', 'countCurrentTransactions'))
    .addSeparator()
    .addSubMenu(ui.createMenu('⚙️ System Tools')
      .addItem('🔄 Setup Hourly Trigger', 'setupVercelTrigger')
      .addItem('📅 Setup Date Controls', 'setupDateControls')
      .addItem('🗑️ Delete All Triggers', 'deleteAllTriggers')
      .addItem('📋 View System Status', 'showSystemStatus'))
    .addSeparator()
    .addSubMenu(ui.createMenu('🛠️ Advanced')
      .addItem('🔄 Force Consolidation', 'consolidateToFormatted')
      .addItem('⏰ Update Last Execution', 'updateLastExecutionTime')
      .addItem('📊 Export Diagnostics', 'exportDiagnostics'))
    .addToUi();
    
  console.log("✅ CryptoWallet menu created successfully");
}

// ===========================================
// QUICK TEST FUNCTIONS
// ===========================================

/**
 * TEST: Vercel endpoint connection
 */
function testVercelConnection() {
  try {
    console.log("🧪 Testing Vercel connection...");
    
    const testPayload = {
      action: "test_connection",
      timestamp: new Date().toISOString()
    };
    
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      payload: JSON.stringify(testPayload),
      muteHttpExceptions: true
    });
    
    const statusCode = response.getResponseCode();
    const responseText = response.getContentText();
    
    if (statusCode === 200) {
      console.log("✅ Vercel connection successful");
      showAlert("Success", "✅ Vercel connection working perfectly!\n\nResponse: " + responseText.substring(0, 200) + "...");
    } else {
      console.error(`❌ Vercel connection failed: ${statusCode}`);
      showAlert("Error", `❌ Vercel connection failed!\n\nStatus: ${statusCode}\nResponse: ${responseText.substring(0, 200)}...`);
    }
    
  } catch (error) {
    console.error("❌ Error testing Vercel connection:", error);
    showAlert("Error", `❌ Connection test failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Count transactions in current sheets
 */
function countCurrentTransactions() {
  try {
    console.log("🔍 Counting current transactions...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Count withdrawals
    const withdrawalsSheet = spreadsheet.getSheetByName(CONFIG.WITHDRAWALS_SHEET);
    const withdrawalsCount = withdrawalsSheet ? Math.max(0, withdrawalsSheet.getLastRow() - 6) : 0;
    
    // Count deposits  
    const depositsSheet = spreadsheet.getSheetByName(CONFIG.DEPOSITS_SHEET);
    const depositsCount = depositsSheet ? Math.max(0, depositsSheet.getLastRow() - 6) : 0;
    
    // Count formatted transactions
    const formattedSheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    const formattedCount = formattedSheet ? Math.max(0, formattedSheet.getLastRow() - 1) : 0;
    
    const report = `📊 Transaction Count Report:

📤 Withdrawals: ${withdrawalsCount}
📥 Deposits: ${depositsCount}
📈 Total Raw: ${withdrawalsCount + depositsCount}
📋 Formatted: ${formattedCount}

📅 Last Update: ${new Date().toLocaleString()}`;

    console.log(report);
    showAlert("Transaction Count", report);
    
  } catch (error) {
    console.error("❌ Error counting transactions:", error);
    showAlert("Error", `❌ Count failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST: Sheet access and structure
 */
function testSheetAccess() {
  try {
    console.log("📈 Testing sheet access...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const sheets = spreadsheet.getSheets();
    
    let report = "📊 Sheet Access Test:\n\n";
    
    // Check each required sheet
    const requiredSheets = [CONFIG.WITHDRAWALS_SHEET, CONFIG.DEPOSITS_SHEET, CONFIG.FORMATTED_SHEET, CONFIG.SETTINGS_SHEET];
    
    requiredSheets.forEach(sheetName => {
      const sheet = spreadsheet.getSheetByName(sheetName);
      if (sheet) {
        report += `✅ ${sheetName}: ${sheet.getLastRow()} rows\n`;
      } else {
        report += `❌ ${sheetName}: Missing!\n`;
      }
    });
    
    report += `\n📋 Total Sheets: ${sheets.length}`;
    
    console.log(report);
    showAlert("Sheet Access", report);
    
  } catch (error) {
    console.error("❌ Error testing sheet access:", error);
    showAlert("Error", `❌ Sheet test failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// SYSTEM TOOLS
// ===========================================

/**
 * Delete all existing triggers
 */
function deleteAllTriggers() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    
    if (triggers.length === 0) {
      showAlert("Info", "ℹ️ No triggers found to delete.");
      return;
    }
    
    triggers.forEach(trigger => {
      ScriptApp.deleteTrigger(trigger);
    });
    
    console.log(`🗑️ Deleted ${triggers.length} triggers`);
    showAlert("Success", `✅ Deleted ${triggers.length} triggers successfully!`);
    
  } catch (error) {
    console.error("❌ Error deleting triggers:", error);
    showAlert("Error", `❌ Failed to delete triggers!\n\nError: ${error.message}`);
  }
}

/**
 * Show comprehensive system status
 */
function showSystemStatus() {
  try {
    console.log("📋 Generating system status...");
    
    const triggers = ScriptApp.getProjectTriggers();
    const settings = getSettingsConfiguration();
    
    let status = "🔍 CryptoWallet System Status:\n\n";
    
    // Triggers status
    status += "⚙️ TRIGGERS:\n";
    if (triggers.length === 0) {
      status += "❌ No triggers active\n";
    } else {
      triggers.forEach(trigger => {
        status += `✅ ${trigger.getHandlerFunction()}: ${trigger.getTriggerSource()}\n`;
      });
    }
    
    // Settings status
    status += "\n📅 SETTINGS:\n";
    status += `Start Date: ${settings.startDate}\n`;
    status += `Last Execution: ${settings.lastExecution || 'Never'}\n`;
    
    // Sheet status
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    status += "\n📊 SHEETS:\n";
    status += `Withdrawals: ${getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET)} rows\n`;
    status += `Deposits: ${getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET)} rows\n`;
    status += `Formatted: ${getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET)} rows\n`;
    
    status += `\n⏰ Generated: ${new Date().toLocaleString()}`;
    
    console.log(status);
    showAlert("System Status", status);
    
  } catch (error) {
    console.error("❌ Error generating system status:", error);
    showAlert("Error", `❌ Status check failed!\n\nError: ${error.message}`);
  }
}

/**
 * Export diagnostics to new sheet
 */
function exportDiagnostics() {
  try {
    console.log("📊 Exporting diagnostics...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Create or get diagnostics sheet
    let diagnosticsSheet;
    try {
      diagnosticsSheet = spreadsheet.getSheetByName("DIAGNOSTICS");
    } catch (e) {
      diagnosticsSheet = spreadsheet.insertSheet("DIAGNOSTICS");
    }
    
    // Clear existing data
    diagnosticsSheet.clear();
    
    // Create diagnostics report
    const timestamp = new Date();
    const settings = getSettingsConfiguration();
    const triggers = ScriptApp.getProjectTriggers();
    
    const diagnosticsData = [
      ["CryptoWallet System Diagnostics", "", ""],
      ["Generated At:", timestamp.toLocaleString(), ""],
      ["", "", ""],
      ["CONFIGURATION", "", ""],
      ["Sheet ID:", CONFIG.SHEET_ID, ""],
      ["Vercel Endpoint:", CONFIG.VERCEL_CRYPTO_ENDPOINT, ""],
      ["", "", ""],
      ["SETTINGS", "", ""],
      ["Start Date:", settings.startDate, ""],
      ["Last Execution:", settings.lastExecution || "Never", ""],
      ["", "", ""],
      ["TRIGGERS", "", ""],
      ["Active Triggers:", triggers.length, ""],
      ...triggers.map(t => ["Trigger:", t.getHandlerFunction(), t.getTriggerSource()]),
      ["", "", ""],
      ["SHEET STATISTICS", "", ""],
      ["Withdrawals Rows:", getSheetRowCount(spreadsheet, CONFIG.WITHDRAWALS_SHEET), ""],
      ["Deposits Rows:", getSheetRowCount(spreadsheet, CONFIG.DEPOSITS_SHEET), ""],
      ["Formatted Rows:", getSheetRowCount(spreadsheet, CONFIG.FORMATTED_SHEET), ""]
    ];
    
    // Write data to sheet
    diagnosticsSheet.getRange(1, 1, diagnosticsData.length, 3).setValues(diagnosticsData);
    
    // Format the sheet
    diagnosticsSheet.getRange("A1").setFontWeight("bold").setFontSize(14);
    diagnosticsSheet.getRange("A:A").setFontWeight("bold");
    diagnosticsSheet.autoResizeColumns(1, 3);
    
    console.log("✅ Diagnostics exported successfully");
    showAlert("Success", "✅ Diagnostics exported to DIAGNOSTICS sheet!");
    
  } catch (error) {
    console.error("❌ Error exporting diagnostics:", error);
    showAlert("Error", `❌ Export failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// MAIN EXECUTION FUNCTIONS (EXISTING)
// ===========================================

/**
 * MAIN FUNCTION - Triggers Vercel and formats data
 */
function mainVercelMode() {
  try {
    console.log("🚀 Starting Vercel-mode crypto data fetch...");
    
    // Step 1: Get settings for date filtering
    const settings = getSettingsConfiguration();
    console.log(`📅 Start Date: ${settings.startDate}`);
    console.log(`📅 Last Execution: ${settings.lastExecution}`);
    
    // Step 2: Trigger Vercel to fetch and write data
    console.log("📡 Triggering Vercel data fetch...");
    triggerVercelDataFetch(settings);
    
    // Step 3: Wait a bit for Vercel to complete
    console.log("⏳ Waiting for Vercel to complete...");
    Utilities.sleep(10000); // 10 seconds
    
    // Step 4: Consolidate and format data
    console.log("🔄 Consolidating to formatted sheet...");
    consolidateToFormatted();
    
    // Step 5: Update last execution timestamp
    updateLastExecutionTime();
    
    console.log("✅ Vercel-mode flow completed successfully");
    showAlert("Success", "✅ Main extraction completed successfully!\n\nCheck the logs for detailed results.");
    
  } catch (error) {
    console.error("❌ Error in Vercel-mode main function:", error);
    showAlert("Error", `❌ Main extraction failed!\n\nError: ${error.message}`);
  }
}

/**
 * Get settings configuration from Settings sheet
 */
function getSettingsConfiguration() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      console.error("Settings sheet not found");
      return {
        startDate: new Date('2024-01-01').toISOString(),
        lastExecution: null
      };
    }
    
    // Read start date from H13
    const startDateCell = settingsSheet.getRange('H13').getValue();
    const startDate = startDateCell ? new Date(startDateCell).toISOString() : new Date('2024-01-01').toISOString();
    
    // Read last execution from H16
    const lastExecutionCell = settingsSheet.getRange('H16').getValue();
    const lastExecution = lastExecutionCell ? new Date(lastExecutionCell).toISOString() : null;
    
    return {
      startDate: startDate,
      lastExecution: lastExecution
    };
    
  } catch (error) {
    console.error("❌ Error reading settings configuration:", error);
    return {
      startDate: new Date('2024-01-01').toISOString(),
      lastExecution: null
    };
  }
}

/**
 * Update last execution timestamp in Settings H16
 */
function updateLastExecutionTime() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      console.error("Settings sheet not found");
      return;
    }
    
    const now = new Date();
    const adjustedNow = adjustTimestampToGST(now.toISOString());
    settingsSheet.getRange('H16').setValue(adjustedNow);
    
    console.log(`✅ Last execution time updated: ${adjustedNow}`);
    
  } catch (error) {
    console.error("❌ Error updating last execution time:", error);
  }
}

/**
 * Trigger Vercel endpoint to fetch and write data
 */
function triggerVercelDataFetch(settings) {
  try {
    const response = UrlFetchApp.fetch(CONFIG.VERCEL_CRYPTO_ENDPOINT, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      payload: JSON.stringify({
        action: "fetch_and_write",
        timestamp: new Date().toISOString(),
        startDate: settings.startDate,
        lastExecution: settings.lastExecution
      }),
      muteHttpExceptions: true
    });
    
    const responseText = response.getContentText();
    const data = JSON.parse(responseText);

    // --- NEW: Print debug logs from Vercel ---
    if (data.debugLogs && Array.isArray(data.debugLogs)) {
      console.log("--- 📡 Vercel Debug Logs Start 📡 ---");
      data.debugLogs.forEach(log => console.log(log));
      console.log("--- 📡 Vercel Debug Logs End 📡 ---");
    }
    // --- End of new code ---
    
    if (response.getResponseCode() !== 200) {
      throw new Error(`Vercel API error: ${response.getResponseCode()} - ${responseText}`);
    }
    
    if (!data.success) {
      throw new Error(`Vercel process failed: ${data.error || 'Unknown error'}`);
    }
    
    console.log(`✅ Vercel processed ${data.transactions} transactions`);
    console.log("📊 Vercel result:", data.sheetsResult);
    
  } catch (error) {
    console.error("❌ Error triggering Vercel:", error);
    throw error;
  }
}

/**
 * Consolidate Withdrawals & Deposits to FORMATTED_TRANSACTIONS
 */
function consolidateToFormatted() {
  try {
    console.log("🔄 Starting consolidation to FORMATTED_TRANSACTIONS...");
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    
    // Read from mockup sheets
    const withdrawals = readMockupSheet(spreadsheet, CONFIG.WITHDRAWALS_SHEET, 'withdrawal');
    const deposits = readMockupSheet(spreadsheet, CONFIG.DEPOSITS_SHEET, 'deposit');
    
    // Combine all transactions
    const allTransactions = [...withdrawals, ...deposits];
    
    // Sort by timestamp (newest first)
    allTransactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    // Update FORMATTED_TRANSACTIONS sheet
    updateFormattedTransactionsSheet(spreadsheet, allTransactions);
    
    console.log(`✅ Consolidated ${allTransactions.length} transactions to FORMATTED_TRANSACTIONS`);
    
  } catch (error) {
    console.error("❌ Error consolidating to formatted sheet:", error);
  }
}

/**
 * Adjust timestamp to +4 hours (Gulf Standard Time)
 */
function adjustTimestampToGST(timestamp) {
  try {
    if (!timestamp) return new Date().toISOString();
    // If timestamp does not end with Z, add Z to treat as UTC
    let date = new Date(timestamp.endsWith('Z') ? timestamp : timestamp + 'Z');
    date.setHours(date.getHours() + 4);
    return date.toISOString();
  } catch (error) {
    console.error("❌ Error adjusting timestamp:", error);
    return timestamp || new Date().toISOString();
  }
}

/**
 * Read data from mockup sheets
 */
function readMockupSheet(spreadsheet, sheetName, transactionType) {
  const transactions = [];
  
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    
    if (!sheet || sheet.getLastRow() <= 6) {
      return transactions;
    }
    
    const data = sheet.getRange(7, 1, sheet.getLastRow() - 6, 12).getValues();
    
    data.forEach((row, index) => {
      if (row[5] && row[6]) { // Platform and Asset must exist
        // Adjust timestamp to +4 hours (GST)
        const originalTimestamp = row[8] || new Date().toISOString();
        const adjustedTimestamp = adjustTimestampToGST(originalTimestamp);
        
        transactions.push({
          id: index + 1,
          timestamp: adjustedTimestamp, // Use adjusted timestamp
          platform: row[5],
          type: transactionType,
          asset: row[6],
          amount: row[7] || '0',
          amount_aed: row[1] || '0', // From green column
          rate: row[3] || getCryptoRate(row[6], 'AED'),
          client: row[0] || '', // Green column
          remarks: transactionType === 'deposit' ? row[4] : row[4], // Green column
          from_address: row[9] || '',
          to_address: row[10] || '',
          tx_id: row[11] || '',
          status: 'Completed',
          network: getNetworkFromAsset(row[6])
        });
      }
    });
    
  } catch (error) {
    console.error(`❌ Error reading ${sheetName}:`, error);
  }
  
  return transactions;
}

/**
 * Update FORMATTED_TRANSACTIONS with consolidated data
 */
function updateFormattedTransactionsSheet(spreadsheet, transactions) {
  try {
    const sheet = spreadsheet.getSheetByName(CONFIG.FORMATTED_SHEET);
    
    if (!sheet) {
      console.error("FORMATTED_TRANSACTIONS sheet not found");
      return;
    }
    
    // Clear existing data (keep headers)
    if (sheet.getLastRow() > 1) {
      sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clear();
    }
    
    if (transactions.length === 0) {
      console.log("No transactions to consolidate");
      return;
    }
    
    // Format for FORMATTED_TRANSACTIONS sheet
    const formattedRows = transactions.map(tx => {
      const aedValue = parseFloat(tx.amount_aed) || (parseFloat(tx.amount) * getCryptoRate(tx.asset, 'AED'));
      
      return [
        tx.timestamp, // Date & Time
        tx.platform, // Platform
        tx.type.charAt(0).toUpperCase() + tx.type.slice(1), // Type
        tx.asset, // Asset
        parseFloat(tx.amount).toFixed(8), // Amount
        `AED ${aedValue.toLocaleString()}`, // AED Value
        tx.rate, // Rate
        tx.client, // Client (from green column)
        tx.remarks, // Remarks (from green column)
        tx.from_address, // From Address
        tx.to_address, // To Address
        tx.tx_id // TX ID
      ];
    });
    
    // Insert consolidated data
    sheet.getRange(2, 1, formattedRows.length, 12).setValues(formattedRows);
    
    console.log(`✅ FORMATTED_TRANSACTIONS updated with ${formattedRows.length} transactions`);
    
  } catch (error) {
    console.error("❌ Error updating FORMATTED_TRANSACTIONS:", error);
  }
}

/**
 * Get cryptocurrency rates
 */
function getCryptoRate(asset, currency) {
  const rates = {
    'BTC': { 'USD': 60000, 'AED': 220200 },
    'ETH': { 'USD': 3000, 'AED': 11010 },
    'USDT': { 'USD': 1, 'AED': 3.67 },
    'USDC': { 'USD': 1, 'AED': 3.67 },
    'SOL': { 'USD': 150, 'AED': 550 },
    'TRX': { 'USD': 0.1, 'AED': 0.37 },
    'BNB': { 'USD': 600, 'AED': 2200 },
    'SEI': { 'USD': 0.4, 'AED': 1.47 }
  };
  
  return rates[asset] ? rates[asset][currency] : 1;
}

/**
 * Get network from asset
 */
function getNetworkFromAsset(asset) {
  const networkMap = {
    'BTC': 'BTC',
    'ETH': 'ETH', 
    'USDT': 'TRC20',
    'USDC': 'ERC20',
    'TRX': 'TRON',
    'SOL': 'SOL',
    'BNB': 'BEP20',
    'SEI': 'SEI',
    'P2P': 'P2P'
  };
  
  return networkMap[asset] || 'Unknown';
}

/**
 * Set up hourly trigger for Vercel-mode
 */
function setupVercelTrigger() {
  try {
    // Delete existing triggers
    ScriptApp.getProjectTriggers().forEach(trigger => {
      if (trigger.getHandlerFunction() === 'mainVercelMode') {
        ScriptApp.deleteTrigger(trigger);
      }
    });
    
    // Create new hourly trigger for Vercel-mode main function
    ScriptApp.newTrigger('mainVercelMode')
      .timeBased()
      .everyHours(1)
      .create();
    
    console.log("✅ Vercel-mode hourly trigger set up successfully");
    showAlert("Success", "✅ Hourly trigger set up successfully!\n\nThe system will now run automatically every hour.");
    
  } catch (error) {
    console.error("❌ Error setting up trigger:", error);
    showAlert("Error", `❌ Trigger setup failed!\n\nError: ${error.message}`);
  }
}

/**
 * TEST FUNCTION: Check Settings date configuration
 */
function testDateSettings() {
  try {
    const settings = getSettingsConfiguration();
    
    let report = "📅 Date Settings Check:\n\n";
    report += `Start Date: ${settings.startDate}\n`;
    report += `Last Execution: ${settings.lastExecution || 'Never'}\n\n`;
    
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    report += "📊 Raw Settings Values:\n";
    report += `H13 (Start Date): ${settingsSheet.getRange('H13').getValue()}\n`;
    report += `H16 (Last Execution): ${settingsSheet.getRange('H16').getValue()}`;
    
    console.log(report);
    showAlert("Date Settings", report);
    
  } catch (error) {
    console.error("❌ Error testing date settings:", error);
    showAlert("Error", `❌ Date settings test failed!\n\nError: ${error.message}`);
  }
}

/**
 * UTILITY: Setup date controls in Settings if missing
 */
function setupDateControls() {
  try {
    const spreadsheet = SpreadsheetApp.openById(CONFIG.SHEET_ID);
    const settingsSheet = spreadsheet.getSheetByName(CONFIG.SETTINGS_SHEET);
    
    if (!settingsSheet) {
      showAlert("Error", "❌ Settings sheet not found!");
      return;
    }
    
    // Add date control labels and default values
    settingsSheet.getRange('G13').setValue('Start Date:').setFontWeight('bold');
    settingsSheet.getRange('H13').setValue(new Date('2025-05-31')); // Updated default
    
    settingsSheet.getRange('G16').setValue('Last Execution:').setFontWeight('bold');
    settingsSheet.getRange('H16').setValue('Not executed yet');
    
    // Format date cells
    settingsSheet.getRange('H13').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    settingsSheet.getRange('H16').setNumberFormat('yyyy-mm-dd hh:mm:ss');
    
    console.log("✅ Date controls set up in Settings sheet");
    showAlert("Success", "✅ Date controls set up successfully!\n\n📅 Start Date: 2025-05-31\n📅 Last Execution will be updated automatically");
    
  } catch (error) {
    console.error("❌ Error setting up date controls:", error);
    showAlert("Error", `❌ Date controls setup failed!\n\nError: ${error.message}`);
  }
}

// ===========================================
// UTILITY FUNCTIONS
// ===========================================

/**
 * Helper: Show alert dialog
 */
function showAlert(title, message) {
  try {
    const ui = SpreadsheetApp.getUi();
    ui.alert(title, message, ui.ButtonSet.OK);
  } catch (error) {
    // Fallback to console if UI not available
    console.log(`${title}: ${message}`);
  }
}

/**
 * Helper: Get sheet row count safely
 */
function getSheetRowCount(spreadsheet, sheetName) {
  try {
    const sheet = spreadsheet.getSheetByName(sheetName);
    return sheet ? Math.max(0, sheet.getLastRow() - (sheetName.includes('FORMATTED') ? 1 : 6)) : 0;
  } catch (error) {
    return 0;
  }
}